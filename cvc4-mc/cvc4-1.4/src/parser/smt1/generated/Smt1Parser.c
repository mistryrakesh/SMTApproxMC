/** \file
 *  This C source file was generated by $ANTLR version 3.4
 *
 *     -  From the grammar source file : /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g
 *     -                            On : 2014-07-13 13:48:57
 *     -                for the parser : Smt1ParserParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


/* =============================================================================
 * This is what the grammar programmer asked us to put at the top of every file.
 */

/**
 ** This file is part of CVC4.
 ** Copyright (c) 2009-2014  New York University and The University of Iowa
 ** See the file COPYING in the top-level source directory for licensing
 ** information.
 **/

/* End of Header action.
 * =============================================================================
 */

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "Smt1Parser.h"


#include "expr/expr.h"
#include "expr/kind.h"
#include "expr/type.h"
#include "parser/antlr_input.h"
#include "parser/parser.h"
#include "parser/smt1/smt1.h"
#include "util/integer.h"
#include "util/output.h"
#include "util/rational.h"
#include <vector>

using namespace CVC4;
using namespace CVC4::parser;

/* These need to be macros so they can refer to the PARSER macro, which will be defined
 * by ANTLR *after* this section. (If they were functions, PARSER would be undefined.) */
#undef PARSER_STATE
#define PARSER_STATE ((Smt1*)PARSER->super)
#undef EXPR_MANAGER
#define EXPR_MANAGER PARSER_STATE->getExprManager()
#undef MK_EXPR
#define MK_EXPR EXPR_MANAGER->mkExpr
#undef MK_CONST
#define MK_CONST EXPR_MANAGER->mkConst


/* ----------------------------------------- */





/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */

#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pSmt1Parser_##scope##_SCOPE
#define SCOPE_STACK(scope)  pSmt1Parser_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pSmt1Parser_##scope##Top
#define	SCOPE_SIZE(scope)		ctx->pSmt1Parser_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

/* Macros for accessing things in the parser
 */

#undef	    PARSER
#undef	    RECOGNIZER
#undef	    HAVEPARSEDRULE
#undef		MEMOIZE
#undef	    INPUT
#undef	    STRSTREAM
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    MATCHT
#undef	    MATCHANYT
#undef	    FOLLOWSTACK
#undef	    FOLLOWPUSH
#undef	    FOLLOWPOP
#undef	    PRECOVER
#undef	    PREPORTERROR
#undef	    LA
#undef	    LT
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    PERRORRECOVERY
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    RECOVERFROMMISMATCHEDSET
#undef	    RECOVERFROMMISMATCHEDELEMENT
#undef		INDEX
#undef      ADAPTOR
#undef		SEEK
#undef	    RULEMEMO
#undef		DBG

#define	    PARSER				ctx->pParser
#define	    RECOGNIZER				PARSER->rec
#define	    PSRSTATE				RECOGNIZER->state
#define	    HAVEPARSEDRULE(r)			RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define	    MEMOIZE(ri,si)			RECOGNIZER->memoize(RECOGNIZER, ri, si)
#define	    INPUT				PARSER->tstream
#define	    STRSTREAM				INPUT
#define	    ISTREAM				INPUT->istream
#define	    INDEX()				ISTREAM->index(INPUT->istream)
#define	    HASEXCEPTION()			(PSRSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION				PSRSTATE->exception
#define	    MATCHT(t, fs)			RECOGNIZER->match(RECOGNIZER, t, fs)
#define	    MATCHANYT()				RECOGNIZER->matchAny(RECOGNIZER)
#define	    FOLLOWSTACK				PSRSTATE->following
#ifdef  SKIP_FOLLOW_SETS
#define	    FOLLOWPUSH(x)
#define	    FOLLOWPOP()
#else
#define	    FOLLOWPUSH(x)			FOLLOWSTACK->push(FOLLOWSTACK, ((void *)(&(x))), NULL)
#define	    FOLLOWPOP()				FOLLOWSTACK->pop(FOLLOWSTACK)
#endif
#define	    PRECOVER()				RECOGNIZER->recover(RECOGNIZER)
#define	    PREPORTERROR()			RECOGNIZER->reportError(RECOGNIZER)
#define	    LA(n)				INPUT->istream->_LA(ISTREAM, n)
#define	    LT(n)				INPUT->_LT(INPUT, n)
#define	    CONSTRUCTEX()			RECOGNIZER->exConstruct(RECOGNIZER)
#define	    CONSUME()				ISTREAM->consume(ISTREAM)
#define	    MARK()				ISTREAM->mark(ISTREAM)
#define	    REWIND(m)				ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()			ISTREAM->rewindLast(ISTREAM)
#define	    SEEK(n)				ISTREAM->seek(ISTREAM, n)
#define	    PERRORRECOVERY			PSRSTATE->errorRecovery
#define	    FAILEDFLAG				PSRSTATE->failed
#define	    HASFAILED()				(FAILEDFLAG == ANTLR3_TRUE)
#define	    BACKTRACKING			PSRSTATE->backtracking
#define	    RECOVERFROMMISMATCHEDSET(s)		RECOGNIZER->recoverFromMismatchedSet(RECOGNIZER, s)
#define	    RECOVERFROMMISMATCHEDELEMENT(e)	RECOGNIZER->recoverFromMismatchedElement(RECOGNIZER, s)
#define     ADAPTOR                         ctx->adaptor
#define		RULEMEMO						PSRSTATE->ruleMemo
#define		DBG								RECOGNIZER->debugger


#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */


/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
pANTLR3_UINT8   Smt1ParserTokenNames[102+4]
     = {
        (pANTLR3_UINT8) "<invalid>",       /* String to print to indicate an invalid token */
        (pANTLR3_UINT8) "<EOR>",
        (pANTLR3_UINT8) "<DOWN>",
        (pANTLR3_UINT8) "<UP>",
        (pANTLR3_UINT8) "ALPHA",
        (pANTLR3_UINT8) "AMPERSAND_TOK",
        (pANTLR3_UINT8) "AND_TOK",
        (pANTLR3_UINT8) "ASSUMPTION_TOK",
        (pANTLR3_UINT8) "ATTR_IDENTIFIER",
        (pANTLR3_UINT8) "AT_TOK",
        (pANTLR3_UINT8) "BENCHMARK_TOK",
        (pANTLR3_UINT8) "BITVECTOR1_BV_CONST",
        (pANTLR3_UINT8) "BITVECTOR_BV_CONST",
        (pANTLR3_UINT8) "BITVECTOR_TOK",
        (pANTLR3_UINT8) "BVADD_TOK",
        (pANTLR3_UINT8) "BVAND_TOK",
        (pANTLR3_UINT8) "BVASHR_TOK",
        (pANTLR3_UINT8) "BVCOMP_TOK",
        (pANTLR3_UINT8) "BVLSHR_TOK",
        (pANTLR3_UINT8) "BVMUL_TOK",
        (pANTLR3_UINT8) "BVNAND_TOK",
        (pANTLR3_UINT8) "BVNEG_TOK",
        (pANTLR3_UINT8) "BVNOR_TOK",
        (pANTLR3_UINT8) "BVNOT_TOK",
        (pANTLR3_UINT8) "BVOR_TOK",
        (pANTLR3_UINT8) "BVSDIV_TOK",
        (pANTLR3_UINT8) "BVSGE_TOK",
        (pANTLR3_UINT8) "BVSGT_TOK",
        (pANTLR3_UINT8) "BVSHL_TOK",
        (pANTLR3_UINT8) "BVSLE_TOK",
        (pANTLR3_UINT8) "BVSLT_TOK",
        (pANTLR3_UINT8) "BVSMOD_TOK",
        (pANTLR3_UINT8) "BVSREM_TOK",
        (pANTLR3_UINT8) "BVSUB_TOK",
        (pANTLR3_UINT8) "BVUDIV_TOK",
        (pANTLR3_UINT8) "BVUGE_TOK",
        (pANTLR3_UINT8) "BVUGT_TOK",
        (pANTLR3_UINT8) "BVULE_TOK",
        (pANTLR3_UINT8) "BVULT_TOK",
        (pANTLR3_UINT8) "BVUREM_TOK",
        (pANTLR3_UINT8) "BVXNOR_TOK",
        (pANTLR3_UINT8) "BVXOR_TOK",
        (pANTLR3_UINT8) "COMMENT",
        (pANTLR3_UINT8) "CONCAT_TOK",
        (pANTLR3_UINT8) "DIGIT",
        (pANTLR3_UINT8) "DISTINCT_TOK",
        (pANTLR3_UINT8) "DIV_TOK",
        (pANTLR3_UINT8) "EQUAL_TOK",
        (pANTLR3_UINT8) "ESCAPE",
        (pANTLR3_UINT8) "EXISTS_TOK",
        (pANTLR3_UINT8) "EXTRACT_TOK",
        (pANTLR3_UINT8) "EXTRAFUNS_TOK",
        (pANTLR3_UINT8) "EXTRAPREDS_TOK",
        (pANTLR3_UINT8) "EXTRASORTS_TOK",
        (pANTLR3_UINT8) "FALSE_TOK",
        (pANTLR3_UINT8) "FLET_IDENTIFIER",
        (pANTLR3_UINT8) "FLET_TOK",
        (pANTLR3_UINT8) "FORALL_TOK",
        (pANTLR3_UINT8) "FORMULA_TOK",
        (pANTLR3_UINT8) "GREATER_THAN_TOK",
        (pANTLR3_UINT8) "IDENTIFIER",
        (pANTLR3_UINT8) "IFF_TOK",
        (pANTLR3_UINT8) "IMPLIES_TOK",
        (pANTLR3_UINT8) "ITE_TOK",
        (pANTLR3_UINT8) "LESS_THAN_TOK",
        (pANTLR3_UINT8) "LET_IDENTIFIER",
        (pANTLR3_UINT8) "LET_TOK",
        (pANTLR3_UINT8) "LOGIC_TOK",
        (pANTLR3_UINT8) "LPAREN_TOK",
        (pANTLR3_UINT8) "MINUS_TOK",
        (pANTLR3_UINT8) "NOTES_TOK",
        (pANTLR3_UINT8) "NOT_TOK",
        (pANTLR3_UINT8) "NUMERAL_TOK",
        (pANTLR3_UINT8) "OR_TOK",
        (pANTLR3_UINT8) "PATTERN_ANNOTATION_BEGIN",
        (pANTLR3_UINT8) "PERCENT_TOK",
        (pANTLR3_UINT8) "PIPE_TOK",
        (pANTLR3_UINT8) "PLUS_TOK",
        (pANTLR3_UINT8) "POUND_TOK",
        (pANTLR3_UINT8) "RATIONAL_TOK",
        (pANTLR3_UINT8) "REPEAT_TOK",
        (pANTLR3_UINT8) "ROTATE_LEFT_TOK",
        (pANTLR3_UINT8) "ROTATE_RIGHT_TOK",
        (pANTLR3_UINT8) "RPAREN_TOK",
        (pANTLR3_UINT8) "SAT_TOK",
        (pANTLR3_UINT8) "SELECT_TOK",
        (pANTLR3_UINT8) "SIGN_EXTEND_TOK",
        (pANTLR3_UINT8) "STAR_TOK",
        (pANTLR3_UINT8) "STATUS_TOK",
        (pANTLR3_UINT8) "STORE_TOK",
        (pANTLR3_UINT8) "STRING_LITERAL",
        (pANTLR3_UINT8) "THEORY_TOK",
        (pANTLR3_UINT8) "TILDE_TOK",
        (pANTLR3_UINT8) "TRUE_TOK",
        (pANTLR3_UINT8) "UNKNOWN_TOK",
        (pANTLR3_UINT8) "UNSAT_TOK",
        (pANTLR3_UINT8) "USER_VALUE",
        (pANTLR3_UINT8) "WHITESPACE",
        (pANTLR3_UINT8) "XOR_TOK",
        (pANTLR3_UINT8) "ZERO_EXTEND_TOK",
        (pANTLR3_UINT8) "':'",
        (pANTLR3_UINT8) "':pat'",
        (pANTLR3_UINT8) "'Array['",
        (pANTLR3_UINT8) "'['",
        (pANTLR3_UINT8) "']'",
        (pANTLR3_UINT8) "'}'"
       };



// Forward declare the locally static matching functions we have generated.
//
static 
 CVC4::parser::smt1::myExpr
	parseExpr    (pSmt1Parser ctx);
static 
 CVC4::Command*
	parseCommand    (pSmt1Parser ctx);
static 
 CVC4::Command*
	benchmark    (pSmt1Parser ctx);
static 
 CVC4::CommandSequence*
	benchAttributes    (pSmt1Parser ctx);
static 
 CVC4::Command*
	benchAttribute    (pSmt1Parser ctx);
static 
 void
	annotatedFormula    (pSmt1Parser ctx, CVC4::Expr& expr);
static 
 void
	annotatedFormulas    (pSmt1Parser ctx, std::vector<CVC4::Expr>& formulas, CVC4::Expr& expr);
static 
 void
	builtinOp    (pSmt1Parser ctx, CVC4::Kind& kind);
static 
 void
	parameterizedOperator    (pSmt1Parser ctx, CVC4::Expr& op);
static 
 void
	bitVectorOperator    (pSmt1Parser ctx, CVC4::Expr& op);
static 
 void
	predicateName    (pSmt1Parser ctx, std::string& name, CVC4::parser::DeclarationCheck check);
static 
 void
	functionName    (pSmt1Parser ctx, std::string& name, CVC4::parser::DeclarationCheck check);
static 
 void
	functionSymbol    (pSmt1Parser ctx, CVC4::Expr& fun);
static 
 void
	attribute    (pSmt1Parser ctx, std::string& s);
static 
 void
	functionDeclaration    (pSmt1Parser ctx, CVC4::Command*& smt_command);
static 
 void
	predicateDeclaration    (pSmt1Parser ctx, CVC4::Command*& smt_command);
static 
 void
	sortDeclaration    (pSmt1Parser ctx, CVC4::Command*& smt_command);
static 
 void
	sortList    (pSmt1Parser ctx, std::vector<CVC4::Type>& sorts);
static 
 void
	sortName    (pSmt1Parser ctx, std::string& name, CVC4::parser::DeclarationCheck check);
static 
 CVC4::parser::smt1::myType
	sortSymbol    (pSmt1Parser ctx);
static 
 void
	status    (pSmt1Parser ctx, CVC4::BenchmarkStatus& status);
static 
 void
	annotation    (pSmt1Parser ctx, CVC4::Command*& smt_command);
static 
 void
	termAnnotation    (pSmt1Parser ctx, CVC4::Expr& expr);
static 
 void
	identifier    (pSmt1Parser ctx, std::string& id, CVC4::parser::DeclarationCheck check, CVC4::parser::SymbolType type);
static 
 void
	let_identifier    (pSmt1Parser ctx, std::string& id, CVC4::parser::DeclarationCheck check);
static 
 void
	flet_identifier    (pSmt1Parser ctx, std::string& id, CVC4::parser::DeclarationCheck check);
static 
 void
	userValue    (pSmt1Parser ctx, std::string& s);
static void	Smt1ParserFree(pSmt1Parser ctx);
static void     Smt1ParserReset (pSmt1Parser ctx);

/* For use in tree output where we are accumulating rule labels via label += ruleRef
 * we need a function that knows how to free a return scope when the list is destroyed.
 * We cannot just use ANTLR3_FREE because in debug tracking mode, this is a macro.
 */
static	void ANTLR3_CDECL freeScope(void * scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "/home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new Smt1Parser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pSmt1Parser
Smt1ParserNew   (pANTLR3_COMMON_TOKEN_STREAM instream)
{
	// See if we can create a new parser with the standard constructor
	//
	return Smt1ParserNewSSD(instream, NULL);
}

/** \brief Create a new Smt1Parser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pSmt1Parser
Smt1ParserNewSSD   (pANTLR3_COMMON_TOKEN_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pSmt1Parser ctx;	    /* Context structure we will build and return   */

    ctx	= (pSmt1Parser) ANTLR3_CALLOC(1, sizeof(Smt1Parser));

    if	(ctx == NULL)
    {
		// Failed to allocate memory for parser context
		//
        return  NULL;
    }

    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * the base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 parser function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function.
     *
     * We don't use the macros defined in Smt1Parser.h here, in order that you can get a sense
     * of what goes where.
     */

    /* Create a base parser/recognizer, using the supplied token stream
     */
    ctx->pParser	    = antlr3ParserNewStream(ANTLR3_SIZE_HINT, instream->tstream, state);
    /* Install the implementation of our Smt1Parser interface
     */
    ctx->parseExpr	= parseExpr;
    ctx->parseCommand	= parseCommand;
    ctx->benchmark	= benchmark;
    ctx->benchAttributes	= benchAttributes;
    ctx->benchAttribute	= benchAttribute;
    ctx->annotatedFormula	= annotatedFormula;
    ctx->annotatedFormulas	= annotatedFormulas;
    ctx->builtinOp	= builtinOp;
    ctx->parameterizedOperator	= parameterizedOperator;
    ctx->bitVectorOperator	= bitVectorOperator;
    ctx->predicateName	= predicateName;
    ctx->functionName	= functionName;
    ctx->functionSymbol	= functionSymbol;
    ctx->attribute	= attribute;
    ctx->functionDeclaration	= functionDeclaration;
    ctx->predicateDeclaration	= predicateDeclaration;
    ctx->sortDeclaration	= sortDeclaration;
    ctx->sortList	= sortList;
    ctx->sortName	= sortName;
    ctx->sortSymbol	= sortSymbol;
    ctx->status	= status;
    ctx->annotation	= annotation;
    ctx->termAnnotation	= termAnnotation;
    ctx->identifier	= identifier;
    ctx->let_identifier	= let_identifier;
    ctx->flet_identifier	= flet_identifier;
    ctx->userValue	= userValue;
    ctx->free			= Smt1ParserFree;
    ctx->reset			= Smt1ParserReset;
    ctx->getGrammarFileName	= getGrammarFileName;

    /* Install the scope pushing methods.
     */

    /* Install the token table
     */
    PSRSTATE->tokenNames   = Smt1ParserTokenNames;


    /* Return the newly built parser to the caller
     */
    return  ctx;
}

static void
Smt1ParserReset (pSmt1Parser ctx)
{
    RECOGNIZER->reset(RECOGNIZER);
}

/** Free the parser resources
 */
 static void
 Smt1ParserFree(pSmt1Parser ctx)
 {
    /* Free any scope memory
     */

	// Free this parser
	//
    ctx->pParser->free(ctx->pParser);


    ANTLR3_FREE(ctx);

    /* Everything is released, so we can return
     */
    return;
 }

/** Return token names used by this 
parser

 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
static pANTLR3_UINT8    *getTokenNames()
{
        return Smt1ParserTokenNames;
}


/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: FOLLOW_annotatedFormula_in_parseExpr105  */
static	ANTLR3_BITWORD FOLLOW_annotatedFormula_in_parseExpr105_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_annotatedFormula_in_parseExpr105	= { FOLLOW_annotatedFormula_in_parseExpr105_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EOF_in_parseExpr112  */
static	ANTLR3_BITWORD FOLLOW_EOF_in_parseExpr112_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_EOF_in_parseExpr112	= { FOLLOW_EOF_in_parseExpr112_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_benchmark_in_parseCommand135  */
static	ANTLR3_BITWORD FOLLOW_benchmark_in_parseCommand135_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_benchmark_in_parseCommand135	= { FOLLOW_benchmark_in_parseCommand135_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_parseCommand143  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_parseCommand143_bits[]	= { ANTLR3_UINT64_LIT(0x1000000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_parseCommand143	= { FOLLOW_LPAREN_TOK_in_parseCommand143_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_parseCommand147  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_parseCommand147_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_parseCommand147	= { FOLLOW_IDENTIFIER_in_parseCommand147_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_benchmark172  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_benchmark172_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000400) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_benchmark172	= { FOLLOW_LPAREN_TOK_in_benchmark172_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BENCHMARK_TOK_in_benchmark174  */
static	ANTLR3_BITWORD FOLLOW_BENCHMARK_TOK_in_benchmark174_bits[]	= { ANTLR3_UINT64_LIT(0x1000000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_BENCHMARK_TOK_in_benchmark174	= { FOLLOW_BENCHMARK_TOK_in_benchmark174_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_benchmark176  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_benchmark176_bits[]	= { ANTLR3_UINT64_LIT(0x0438000000000180), ANTLR3_UINT64_LIT(0x0000000001000448) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_benchmark176	= { FOLLOW_IDENTIFIER_in_benchmark176_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_benchAttributes_in_benchmark182  */
static	ANTLR3_BITWORD FOLLOW_benchAttributes_in_benchmark182_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_benchAttributes_in_benchmark182	= { FOLLOW_benchAttributes_in_benchmark182_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_benchmark184  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_benchmark184_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_benchmark184	= { FOLLOW_RPAREN_TOK_in_benchmark184_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EOF_in_benchmark195  */
static	ANTLR3_BITWORD FOLLOW_EOF_in_benchmark195_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_EOF_in_benchmark195	= { FOLLOW_EOF_in_benchmark195_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_benchAttribute_in_benchAttributes226  */
static	ANTLR3_BITWORD FOLLOW_benchAttribute_in_benchAttributes226_bits[]	= { ANTLR3_UINT64_LIT(0x0438000000000182), ANTLR3_UINT64_LIT(0x0000000001000448) };
static  ANTLR3_BITSET_LIST FOLLOW_benchAttribute_in_benchAttributes226	= { FOLLOW_benchAttribute_in_benchAttributes226_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LOGIC_TOK_in_benchAttribute255  */
static	ANTLR3_BITWORD FOLLOW_LOGIC_TOK_in_benchAttribute255_bits[]	= { ANTLR3_UINT64_LIT(0x1000000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LOGIC_TOK_in_benchAttribute255	= { FOLLOW_LOGIC_TOK_in_benchAttribute255_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_identifier_in_benchAttribute257  */
static	ANTLR3_BITWORD FOLLOW_identifier_in_benchAttribute257_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_identifier_in_benchAttribute257	= { FOLLOW_identifier_in_benchAttribute257_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ASSUMPTION_TOK_in_benchAttribute270  */
static	ANTLR3_BITWORD FOLLOW_ASSUMPTION_TOK_in_benchAttribute270_bits[]	= { ANTLR3_UINT64_LIT(0x10C0000000001800), ANTLR3_UINT64_LIT(0x0000000020008112) };
static  ANTLR3_BITSET_LIST FOLLOW_ASSUMPTION_TOK_in_benchAttribute270	= { FOLLOW_ASSUMPTION_TOK_in_benchAttribute270_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_annotatedFormula_in_benchAttribute272  */
static	ANTLR3_BITWORD FOLLOW_annotatedFormula_in_benchAttribute272_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_annotatedFormula_in_benchAttribute272	= { FOLLOW_annotatedFormula_in_benchAttribute272_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FORMULA_TOK_in_benchAttribute285  */
static	ANTLR3_BITWORD FOLLOW_FORMULA_TOK_in_benchAttribute285_bits[]	= { ANTLR3_UINT64_LIT(0x10C0000000001800), ANTLR3_UINT64_LIT(0x0000000020008112) };
static  ANTLR3_BITSET_LIST FOLLOW_FORMULA_TOK_in_benchAttribute285	= { FOLLOW_FORMULA_TOK_in_benchAttribute285_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_annotatedFormula_in_benchAttribute287  */
static	ANTLR3_BITWORD FOLLOW_annotatedFormula_in_benchAttribute287_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_annotatedFormula_in_benchAttribute287	= { FOLLOW_annotatedFormula_in_benchAttribute287_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STATUS_TOK_in_benchAttribute300  */
static	ANTLR3_BITWORD FOLLOW_STATUS_TOK_in_benchAttribute300_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x00000000C0100000) };
static  ANTLR3_BITSET_LIST FOLLOW_STATUS_TOK_in_benchAttribute300	= { FOLLOW_STATUS_TOK_in_benchAttribute300_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_status_in_benchAttribute302  */
static	ANTLR3_BITWORD FOLLOW_status_in_benchAttribute302_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_status_in_benchAttribute302	= { FOLLOW_status_in_benchAttribute302_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EXTRAFUNS_TOK_in_benchAttribute315  */
static	ANTLR3_BITWORD FOLLOW_EXTRAFUNS_TOK_in_benchAttribute315_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_EXTRAFUNS_TOK_in_benchAttribute315	= { FOLLOW_EXTRAFUNS_TOK_in_benchAttribute315_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_benchAttribute317  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_benchAttribute317_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_benchAttribute317	= { FOLLOW_LPAREN_TOK_in_benchAttribute317_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_functionDeclaration_in_benchAttribute331  */
static	ANTLR3_BITWORD FOLLOW_functionDeclaration_in_benchAttribute331_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000080010) };
static  ANTLR3_BITSET_LIST FOLLOW_functionDeclaration_in_benchAttribute331	= { FOLLOW_functionDeclaration_in_benchAttribute331_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_benchAttribute349  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_benchAttribute349_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_benchAttribute349	= { FOLLOW_RPAREN_TOK_in_benchAttribute349_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EXTRAPREDS_TOK_in_benchAttribute355  */
static	ANTLR3_BITWORD FOLLOW_EXTRAPREDS_TOK_in_benchAttribute355_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_EXTRAPREDS_TOK_in_benchAttribute355	= { FOLLOW_EXTRAPREDS_TOK_in_benchAttribute355_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_benchAttribute357  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_benchAttribute357_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_benchAttribute357	= { FOLLOW_LPAREN_TOK_in_benchAttribute357_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_predicateDeclaration_in_benchAttribute373  */
static	ANTLR3_BITWORD FOLLOW_predicateDeclaration_in_benchAttribute373_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000080010) };
static  ANTLR3_BITSET_LIST FOLLOW_predicateDeclaration_in_benchAttribute373	= { FOLLOW_predicateDeclaration_in_benchAttribute373_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_benchAttribute391  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_benchAttribute391_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_benchAttribute391	= { FOLLOW_RPAREN_TOK_in_benchAttribute391_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EXTRASORTS_TOK_in_benchAttribute397  */
static	ANTLR3_BITWORD FOLLOW_EXTRASORTS_TOK_in_benchAttribute397_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_EXTRASORTS_TOK_in_benchAttribute397	= { FOLLOW_EXTRASORTS_TOK_in_benchAttribute397_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_benchAttribute399  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_benchAttribute399_bits[]	= { ANTLR3_UINT64_LIT(0x1000000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_benchAttribute399	= { FOLLOW_LPAREN_TOK_in_benchAttribute399_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortDeclaration_in_benchAttribute415  */
static	ANTLR3_BITWORD FOLLOW_sortDeclaration_in_benchAttribute415_bits[]	= { ANTLR3_UINT64_LIT(0x1000000000000000), ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_sortDeclaration_in_benchAttribute415	= { FOLLOW_sortDeclaration_in_benchAttribute415_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_benchAttribute433  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_benchAttribute433_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_benchAttribute433	= { FOLLOW_RPAREN_TOK_in_benchAttribute433_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NOTES_TOK_in_benchAttribute439  */
static	ANTLR3_BITWORD FOLLOW_NOTES_TOK_in_benchAttribute439_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_NOTES_TOK_in_benchAttribute439	= { FOLLOW_NOTES_TOK_in_benchAttribute439_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_LITERAL_in_benchAttribute441  */
static	ANTLR3_BITWORD FOLLOW_STRING_LITERAL_in_benchAttribute441_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_LITERAL_in_benchAttribute441	= { FOLLOW_STRING_LITERAL_in_benchAttribute441_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_annotation_in_benchAttribute453  */
static	ANTLR3_BITWORD FOLLOW_annotation_in_benchAttribute453_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_annotation_in_benchAttribute453	= { FOLLOW_annotation_in_benchAttribute453_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_annotatedFormula481  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_annotatedFormula481_bits[]	= { ANTLR3_UINT64_LIT(0x6800EBFFFFFFC040), ANTLR3_UINT64_LIT(0x0000000412A022A1) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_annotatedFormula481	= { FOLLOW_LPAREN_TOK_in_annotatedFormula481_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_builtinOp_in_annotatedFormula483  */
static	ANTLR3_BITWORD FOLLOW_builtinOp_in_annotatedFormula483_bits[]	= { ANTLR3_UINT64_LIT(0x10C0000000001800), ANTLR3_UINT64_LIT(0x0000000020008112) };
static  ANTLR3_BITSET_LIST FOLLOW_builtinOp_in_annotatedFormula483	= { FOLLOW_builtinOp_in_annotatedFormula483_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_annotatedFormulas_in_annotatedFormula486  */
static	ANTLR3_BITWORD FOLLOW_annotatedFormulas_in_annotatedFormula486_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100), ANTLR3_UINT64_LIT(0x0000002000080400) };
static  ANTLR3_BITSET_LIST FOLLOW_annotatedFormulas_in_annotatedFormula486	= { FOLLOW_annotatedFormulas_in_annotatedFormula486_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_termAnnotation_in_annotatedFormula499  */
static	ANTLR3_BITWORD FOLLOW_termAnnotation_in_annotatedFormula499_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100), ANTLR3_UINT64_LIT(0x0000002000080400) };
static  ANTLR3_BITSET_LIST FOLLOW_termAnnotation_in_annotatedFormula499	= { FOLLOW_termAnnotation_in_annotatedFormula499_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_annotatedFormula503  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_annotatedFormula503_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_annotatedFormula503	= { FOLLOW_RPAREN_TOK_in_annotatedFormula503_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_annotatedFormula516  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_annotatedFormula516_bits[]	= { ANTLR3_UINT64_LIT(0x0202000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_annotatedFormula516	= { FOLLOW_LPAREN_TOK_in_annotatedFormula516_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FORALL_TOK_in_annotatedFormula524  */
static	ANTLR3_BITWORD FOLLOW_FORALL_TOK_in_annotatedFormula524_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_FORALL_TOK_in_annotatedFormula524	= { FOLLOW_FORALL_TOK_in_annotatedFormula524_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EXISTS_TOK_in_annotatedFormula530  */
static	ANTLR3_BITWORD FOLLOW_EXISTS_TOK_in_annotatedFormula530_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_EXISTS_TOK_in_annotatedFormula530	= { FOLLOW_EXISTS_TOK_in_annotatedFormula530_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_annotatedFormula548  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_annotatedFormula548_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_annotatedFormula548	= { FOLLOW_LPAREN_TOK_in_annotatedFormula548_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_let_identifier_in_annotatedFormula550  */
static	ANTLR3_BITWORD FOLLOW_let_identifier_in_annotatedFormula550_bits[]	= { ANTLR3_UINT64_LIT(0x1000000000002000), ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_let_identifier_in_annotatedFormula550	= { FOLLOW_let_identifier_in_annotatedFormula550_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortSymbol_in_annotatedFormula555  */
static	ANTLR3_BITWORD FOLLOW_sortSymbol_in_annotatedFormula555_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_sortSymbol_in_annotatedFormula555	= { FOLLOW_sortSymbol_in_annotatedFormula555_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_annotatedFormula557  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_annotatedFormula557_bits[]	= { ANTLR3_UINT64_LIT(0x10C0000000001800), ANTLR3_UINT64_LIT(0x0000000020008112) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_annotatedFormula557	= { FOLLOW_RPAREN_TOK_in_annotatedFormula557_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_annotatedFormula_in_annotatedFormula578  */
static	ANTLR3_BITWORD FOLLOW_annotatedFormula_in_annotatedFormula578_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100), ANTLR3_UINT64_LIT(0x0000002000080400) };
static  ANTLR3_BITSET_LIST FOLLOW_annotatedFormula_in_annotatedFormula578	= { FOLLOW_annotatedFormula_in_annotatedFormula578_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_termAnnotation_in_annotatedFormula591  */
static	ANTLR3_BITWORD FOLLOW_termAnnotation_in_annotatedFormula591_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100), ANTLR3_UINT64_LIT(0x0000002000080400) };
static  ANTLR3_BITSET_LIST FOLLOW_termAnnotation_in_annotatedFormula591	= { FOLLOW_termAnnotation_in_annotatedFormula591_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_annotatedFormula595  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_annotatedFormula595_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_annotatedFormula595	= { FOLLOW_RPAREN_TOK_in_annotatedFormula595_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_annotatedFormula630  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_annotatedFormula630_bits[]	= { ANTLR3_UINT64_LIT(0x1004000000000000), ANTLR3_UINT64_LIT(0x0000000800470000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_annotatedFormula630	= { FOLLOW_LPAREN_TOK_in_annotatedFormula630_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_parameterizedOperator_in_annotatedFormula636  */
static	ANTLR3_BITWORD FOLLOW_parameterizedOperator_in_annotatedFormula636_bits[]	= { ANTLR3_UINT64_LIT(0x10C0000000001800), ANTLR3_UINT64_LIT(0x0000000020008112) };
static  ANTLR3_BITSET_LIST FOLLOW_parameterizedOperator_in_annotatedFormula636	= { FOLLOW_parameterizedOperator_in_annotatedFormula636_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_annotatedFormulas_in_annotatedFormula643  */
static	ANTLR3_BITWORD FOLLOW_annotatedFormulas_in_annotatedFormula643_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100), ANTLR3_UINT64_LIT(0x0000002000080400) };
static  ANTLR3_BITSET_LIST FOLLOW_annotatedFormulas_in_annotatedFormula643	= { FOLLOW_annotatedFormulas_in_annotatedFormula643_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_termAnnotation_in_annotatedFormula661  */
static	ANTLR3_BITWORD FOLLOW_termAnnotation_in_annotatedFormula661_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100), ANTLR3_UINT64_LIT(0x0000002000080400) };
static  ANTLR3_BITSET_LIST FOLLOW_termAnnotation_in_annotatedFormula661	= { FOLLOW_termAnnotation_in_annotatedFormula661_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_annotatedFormula665  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_annotatedFormula665_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_annotatedFormula665	= { FOLLOW_RPAREN_TOK_in_annotatedFormula665_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_annotatedFormula678  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_annotatedFormula678_bits[]	= { ANTLR3_UINT64_LIT(0x8000000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_annotatedFormula678	= { FOLLOW_LPAREN_TOK_in_annotatedFormula678_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ITE_TOK_in_annotatedFormula680  */
static	ANTLR3_BITWORD FOLLOW_ITE_TOK_in_annotatedFormula680_bits[]	= { ANTLR3_UINT64_LIT(0x10C0000000001800), ANTLR3_UINT64_LIT(0x0000000020008112) };
static  ANTLR3_BITSET_LIST FOLLOW_ITE_TOK_in_annotatedFormula680	= { FOLLOW_ITE_TOK_in_annotatedFormula680_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_annotatedFormula_in_annotatedFormula686  */
static	ANTLR3_BITWORD FOLLOW_annotatedFormula_in_annotatedFormula686_bits[]	= { ANTLR3_UINT64_LIT(0x10C0000000001800), ANTLR3_UINT64_LIT(0x0000000020008112) };
static  ANTLR3_BITSET_LIST FOLLOW_annotatedFormula_in_annotatedFormula686	= { FOLLOW_annotatedFormula_in_annotatedFormula686_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_annotatedFormula_in_annotatedFormula699  */
static	ANTLR3_BITWORD FOLLOW_annotatedFormula_in_annotatedFormula699_bits[]	= { ANTLR3_UINT64_LIT(0x10C0000000001800), ANTLR3_UINT64_LIT(0x0000000020008112) };
static  ANTLR3_BITSET_LIST FOLLOW_annotatedFormula_in_annotatedFormula699	= { FOLLOW_annotatedFormula_in_annotatedFormula699_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_annotatedFormula_in_annotatedFormula712  */
static	ANTLR3_BITWORD FOLLOW_annotatedFormula_in_annotatedFormula712_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100), ANTLR3_UINT64_LIT(0x0000002000080400) };
static  ANTLR3_BITSET_LIST FOLLOW_annotatedFormula_in_annotatedFormula712	= { FOLLOW_annotatedFormula_in_annotatedFormula712_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_termAnnotation_in_annotatedFormula725  */
static	ANTLR3_BITWORD FOLLOW_termAnnotation_in_annotatedFormula725_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100), ANTLR3_UINT64_LIT(0x0000002000080400) };
static  ANTLR3_BITSET_LIST FOLLOW_termAnnotation_in_annotatedFormula725	= { FOLLOW_termAnnotation_in_annotatedFormula725_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_annotatedFormula729  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_annotatedFormula729_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_annotatedFormula729	= { FOLLOW_RPAREN_TOK_in_annotatedFormula729_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_annotatedFormula742  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_annotatedFormula742_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000), ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_annotatedFormula742	= { FOLLOW_LPAREN_TOK_in_annotatedFormula742_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LET_TOK_in_annotatedFormula750  */
static	ANTLR3_BITWORD FOLLOW_LET_TOK_in_annotatedFormula750_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_LET_TOK_in_annotatedFormula750	= { FOLLOW_LET_TOK_in_annotatedFormula750_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_annotatedFormula752  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_annotatedFormula752_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_annotatedFormula752	= { FOLLOW_LPAREN_TOK_in_annotatedFormula752_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_let_identifier_in_annotatedFormula754  */
static	ANTLR3_BITWORD FOLLOW_let_identifier_in_annotatedFormula754_bits[]	= { ANTLR3_UINT64_LIT(0x10C0000000001800), ANTLR3_UINT64_LIT(0x0000000020008112) };
static  ANTLR3_BITSET_LIST FOLLOW_let_identifier_in_annotatedFormula754	= { FOLLOW_let_identifier_in_annotatedFormula754_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FLET_TOK_in_annotatedFormula765  */
static	ANTLR3_BITWORD FOLLOW_FLET_TOK_in_annotatedFormula765_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_FLET_TOK_in_annotatedFormula765	= { FOLLOW_FLET_TOK_in_annotatedFormula765_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_annotatedFormula767  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_annotatedFormula767_bits[]	= { ANTLR3_UINT64_LIT(0x0080000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_annotatedFormula767	= { FOLLOW_LPAREN_TOK_in_annotatedFormula767_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_flet_identifier_in_annotatedFormula769  */
static	ANTLR3_BITWORD FOLLOW_flet_identifier_in_annotatedFormula769_bits[]	= { ANTLR3_UINT64_LIT(0x10C0000000001800), ANTLR3_UINT64_LIT(0x0000000020008112) };
static  ANTLR3_BITSET_LIST FOLLOW_flet_identifier_in_annotatedFormula769	= { FOLLOW_flet_identifier_in_annotatedFormula769_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_annotatedFormula_in_annotatedFormula778  */
static	ANTLR3_BITWORD FOLLOW_annotatedFormula_in_annotatedFormula778_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_annotatedFormula_in_annotatedFormula778	= { FOLLOW_annotatedFormula_in_annotatedFormula778_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_annotatedFormula781  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_annotatedFormula781_bits[]	= { ANTLR3_UINT64_LIT(0x10C0000000001800), ANTLR3_UINT64_LIT(0x0000000020008112) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_annotatedFormula781	= { FOLLOW_RPAREN_TOK_in_annotatedFormula781_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_annotatedFormula_in_annotatedFormula793  */
static	ANTLR3_BITWORD FOLLOW_annotatedFormula_in_annotatedFormula793_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100), ANTLR3_UINT64_LIT(0x0000002000080400) };
static  ANTLR3_BITSET_LIST FOLLOW_annotatedFormula_in_annotatedFormula793	= { FOLLOW_annotatedFormula_in_annotatedFormula793_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_termAnnotation_in_annotatedFormula800  */
static	ANTLR3_BITWORD FOLLOW_termAnnotation_in_annotatedFormula800_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100), ANTLR3_UINT64_LIT(0x0000002000080400) };
static  ANTLR3_BITSET_LIST FOLLOW_termAnnotation_in_annotatedFormula800	= { FOLLOW_termAnnotation_in_annotatedFormula800_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_annotatedFormula804  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_annotatedFormula804_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_annotatedFormula804	= { FOLLOW_RPAREN_TOK_in_annotatedFormula804_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TRUE_TOK_in_annotatedFormula823  */
static	ANTLR3_BITWORD FOLLOW_TRUE_TOK_in_annotatedFormula823_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TRUE_TOK_in_annotatedFormula823	= { FOLLOW_TRUE_TOK_in_annotatedFormula823_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FALSE_TOK_in_annotatedFormula840  */
static	ANTLR3_BITWORD FOLLOW_FALSE_TOK_in_annotatedFormula840_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_FALSE_TOK_in_annotatedFormula840	= { FOLLOW_FALSE_TOK_in_annotatedFormula840_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMERAL_TOK_in_annotatedFormula856  */
static	ANTLR3_BITWORD FOLLOW_NUMERAL_TOK_in_annotatedFormula856_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMERAL_TOK_in_annotatedFormula856	= { FOLLOW_NUMERAL_TOK_in_annotatedFormula856_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RATIONAL_TOK_in_annotatedFormula868  */
static	ANTLR3_BITWORD FOLLOW_RATIONAL_TOK_in_annotatedFormula868_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RATIONAL_TOK_in_annotatedFormula868	= { FOLLOW_RATIONAL_TOK_in_annotatedFormula868_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BITVECTOR_BV_CONST_in_annotatedFormula884  */
static	ANTLR3_BITWORD FOLLOW_BITVECTOR_BV_CONST_in_annotatedFormula884_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_BITVECTOR_BV_CONST_in_annotatedFormula884	= { FOLLOW_BITVECTOR_BV_CONST_in_annotatedFormula884_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_103_in_annotatedFormula886  */
static	ANTLR3_BITWORD FOLLOW_103_in_annotatedFormula886_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_103_in_annotatedFormula886	= { FOLLOW_103_in_annotatedFormula886_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMERAL_TOK_in_annotatedFormula892  */
static	ANTLR3_BITWORD FOLLOW_NUMERAL_TOK_in_annotatedFormula892_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000010000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMERAL_TOK_in_annotatedFormula892	= { FOLLOW_NUMERAL_TOK_in_annotatedFormula892_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_104_in_annotatedFormula894  */
static	ANTLR3_BITWORD FOLLOW_104_in_annotatedFormula894_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_104_in_annotatedFormula894	= { FOLLOW_104_in_annotatedFormula894_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BITVECTOR1_BV_CONST_in_annotatedFormula910  */
static	ANTLR3_BITWORD FOLLOW_BITVECTOR1_BV_CONST_in_annotatedFormula910_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BITVECTOR1_BV_CONST_in_annotatedFormula910	= { FOLLOW_BITVECTOR1_BV_CONST_in_annotatedFormula910_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_identifier_in_annotatedFormula942  */
static	ANTLR3_BITWORD FOLLOW_identifier_in_annotatedFormula942_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_identifier_in_annotatedFormula942	= { FOLLOW_identifier_in_annotatedFormula942_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_let_identifier_in_annotatedFormula953  */
static	ANTLR3_BITWORD FOLLOW_let_identifier_in_annotatedFormula953_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_let_identifier_in_annotatedFormula953	= { FOLLOW_let_identifier_in_annotatedFormula953_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_flet_identifier_in_annotatedFormula964  */
static	ANTLR3_BITWORD FOLLOW_flet_identifier_in_annotatedFormula964_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_flet_identifier_in_annotatedFormula964	= { FOLLOW_flet_identifier_in_annotatedFormula964_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_annotatedFormula_in_annotatedFormulas993  */
static	ANTLR3_BITWORD FOLLOW_annotatedFormula_in_annotatedFormulas993_bits[]	= { ANTLR3_UINT64_LIT(0x10C0000000001802), ANTLR3_UINT64_LIT(0x0000000020008112) };
static  ANTLR3_BITSET_LIST FOLLOW_annotatedFormula_in_annotatedFormulas993	= { FOLLOW_annotatedFormula_in_annotatedFormulas993_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NOT_TOK_in_builtinOp1020  */
static	ANTLR3_BITWORD FOLLOW_NOT_TOK_in_builtinOp1020_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_NOT_TOK_in_builtinOp1020	= { FOLLOW_NOT_TOK_in_builtinOp1020_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IMPLIES_TOK_in_builtinOp1033  */
static	ANTLR3_BITWORD FOLLOW_IMPLIES_TOK_in_builtinOp1033_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IMPLIES_TOK_in_builtinOp1033	= { FOLLOW_IMPLIES_TOK_in_builtinOp1033_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_AND_TOK_in_builtinOp1042  */
static	ANTLR3_BITWORD FOLLOW_AND_TOK_in_builtinOp1042_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_AND_TOK_in_builtinOp1042	= { FOLLOW_AND_TOK_in_builtinOp1042_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OR_TOK_in_builtinOp1055  */
static	ANTLR3_BITWORD FOLLOW_OR_TOK_in_builtinOp1055_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_OR_TOK_in_builtinOp1055	= { FOLLOW_OR_TOK_in_builtinOp1055_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_XOR_TOK_in_builtinOp1069  */
static	ANTLR3_BITWORD FOLLOW_XOR_TOK_in_builtinOp1069_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_XOR_TOK_in_builtinOp1069	= { FOLLOW_XOR_TOK_in_builtinOp1069_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IFF_TOK_in_builtinOp1082  */
static	ANTLR3_BITWORD FOLLOW_IFF_TOK_in_builtinOp1082_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IFF_TOK_in_builtinOp1082	= { FOLLOW_IFF_TOK_in_builtinOp1082_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUAL_TOK_in_builtinOp1095  */
static	ANTLR3_BITWORD FOLLOW_EQUAL_TOK_in_builtinOp1095_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUAL_TOK_in_builtinOp1095	= { FOLLOW_EQUAL_TOK_in_builtinOp1095_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DISTINCT_TOK_in_builtinOp1106  */
static	ANTLR3_BITWORD FOLLOW_DISTINCT_TOK_in_builtinOp1106_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DISTINCT_TOK_in_builtinOp1106	= { FOLLOW_DISTINCT_TOK_in_builtinOp1106_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_GREATER_THAN_TOK_in_builtinOp1117  */
static	ANTLR3_BITWORD FOLLOW_GREATER_THAN_TOK_in_builtinOp1117_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_GREATER_THAN_TOK_in_builtinOp1117	= { FOLLOW_GREATER_THAN_TOK_in_builtinOp1117_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_GREATER_THAN_TOK_in_builtinOp1142  */
static	ANTLR3_BITWORD FOLLOW_GREATER_THAN_TOK_in_builtinOp1142_bits[]	= { ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_GREATER_THAN_TOK_in_builtinOp1142	= { FOLLOW_GREATER_THAN_TOK_in_builtinOp1142_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUAL_TOK_in_builtinOp1144  */
static	ANTLR3_BITWORD FOLLOW_EQUAL_TOK_in_builtinOp1144_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUAL_TOK_in_builtinOp1144	= { FOLLOW_EQUAL_TOK_in_builtinOp1144_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LESS_THAN_TOK_in_builtinOp1169  */
static	ANTLR3_BITWORD FOLLOW_LESS_THAN_TOK_in_builtinOp1169_bits[]	= { ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LESS_THAN_TOK_in_builtinOp1169	= { FOLLOW_LESS_THAN_TOK_in_builtinOp1169_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUAL_TOK_in_builtinOp1171  */
static	ANTLR3_BITWORD FOLLOW_EQUAL_TOK_in_builtinOp1171_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUAL_TOK_in_builtinOp1171	= { FOLLOW_EQUAL_TOK_in_builtinOp1171_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LESS_THAN_TOK_in_builtinOp1196  */
static	ANTLR3_BITWORD FOLLOW_LESS_THAN_TOK_in_builtinOp1196_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_LESS_THAN_TOK_in_builtinOp1196	= { FOLLOW_LESS_THAN_TOK_in_builtinOp1196_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PLUS_TOK_in_builtinOp1221  */
static	ANTLR3_BITWORD FOLLOW_PLUS_TOK_in_builtinOp1221_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_PLUS_TOK_in_builtinOp1221	= { FOLLOW_PLUS_TOK_in_builtinOp1221_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STAR_TOK_in_builtinOp1233  */
static	ANTLR3_BITWORD FOLLOW_STAR_TOK_in_builtinOp1233_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_STAR_TOK_in_builtinOp1233	= { FOLLOW_STAR_TOK_in_builtinOp1233_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TILDE_TOK_in_builtinOp1245  */
static	ANTLR3_BITWORD FOLLOW_TILDE_TOK_in_builtinOp1245_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TILDE_TOK_in_builtinOp1245	= { FOLLOW_TILDE_TOK_in_builtinOp1245_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_MINUS_TOK_in_builtinOp1256  */
static	ANTLR3_BITWORD FOLLOW_MINUS_TOK_in_builtinOp1256_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_MINUS_TOK_in_builtinOp1256	= { FOLLOW_MINUS_TOK_in_builtinOp1256_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIV_TOK_in_builtinOp1267  */
static	ANTLR3_BITWORD FOLLOW_DIV_TOK_in_builtinOp1267_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DIV_TOK_in_builtinOp1267	= { FOLLOW_DIV_TOK_in_builtinOp1267_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CONCAT_TOK_in_builtinOp1283  */
static	ANTLR3_BITWORD FOLLOW_CONCAT_TOK_in_builtinOp1283_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CONCAT_TOK_in_builtinOp1283	= { FOLLOW_CONCAT_TOK_in_builtinOp1283_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVAND_TOK_in_builtinOp1293  */
static	ANTLR3_BITWORD FOLLOW_BVAND_TOK_in_builtinOp1293_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BVAND_TOK_in_builtinOp1293	= { FOLLOW_BVAND_TOK_in_builtinOp1293_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVOR_TOK_in_builtinOp1304  */
static	ANTLR3_BITWORD FOLLOW_BVOR_TOK_in_builtinOp1304_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BVOR_TOK_in_builtinOp1304	= { FOLLOW_BVOR_TOK_in_builtinOp1304_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVXOR_TOK_in_builtinOp1316  */
static	ANTLR3_BITWORD FOLLOW_BVXOR_TOK_in_builtinOp1316_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BVXOR_TOK_in_builtinOp1316	= { FOLLOW_BVXOR_TOK_in_builtinOp1316_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVNOT_TOK_in_builtinOp1327  */
static	ANTLR3_BITWORD FOLLOW_BVNOT_TOK_in_builtinOp1327_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BVNOT_TOK_in_builtinOp1327	= { FOLLOW_BVNOT_TOK_in_builtinOp1327_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVNAND_TOK_in_builtinOp1338  */
static	ANTLR3_BITWORD FOLLOW_BVNAND_TOK_in_builtinOp1338_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BVNAND_TOK_in_builtinOp1338	= { FOLLOW_BVNAND_TOK_in_builtinOp1338_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVNOR_TOK_in_builtinOp1348  */
static	ANTLR3_BITWORD FOLLOW_BVNOR_TOK_in_builtinOp1348_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BVNOR_TOK_in_builtinOp1348	= { FOLLOW_BVNOR_TOK_in_builtinOp1348_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVXNOR_TOK_in_builtinOp1359  */
static	ANTLR3_BITWORD FOLLOW_BVXNOR_TOK_in_builtinOp1359_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BVXNOR_TOK_in_builtinOp1359	= { FOLLOW_BVXNOR_TOK_in_builtinOp1359_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVCOMP_TOK_in_builtinOp1369  */
static	ANTLR3_BITWORD FOLLOW_BVCOMP_TOK_in_builtinOp1369_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BVCOMP_TOK_in_builtinOp1369	= { FOLLOW_BVCOMP_TOK_in_builtinOp1369_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVMUL_TOK_in_builtinOp1379  */
static	ANTLR3_BITWORD FOLLOW_BVMUL_TOK_in_builtinOp1379_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BVMUL_TOK_in_builtinOp1379	= { FOLLOW_BVMUL_TOK_in_builtinOp1379_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVADD_TOK_in_builtinOp1390  */
static	ANTLR3_BITWORD FOLLOW_BVADD_TOK_in_builtinOp1390_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BVADD_TOK_in_builtinOp1390	= { FOLLOW_BVADD_TOK_in_builtinOp1390_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVSUB_TOK_in_builtinOp1401  */
static	ANTLR3_BITWORD FOLLOW_BVSUB_TOK_in_builtinOp1401_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BVSUB_TOK_in_builtinOp1401	= { FOLLOW_BVSUB_TOK_in_builtinOp1401_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVNEG_TOK_in_builtinOp1412  */
static	ANTLR3_BITWORD FOLLOW_BVNEG_TOK_in_builtinOp1412_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BVNEG_TOK_in_builtinOp1412	= { FOLLOW_BVNEG_TOK_in_builtinOp1412_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVUDIV_TOK_in_builtinOp1423  */
static	ANTLR3_BITWORD FOLLOW_BVUDIV_TOK_in_builtinOp1423_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BVUDIV_TOK_in_builtinOp1423	= { FOLLOW_BVUDIV_TOK_in_builtinOp1423_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVUREM_TOK_in_builtinOp1433  */
static	ANTLR3_BITWORD FOLLOW_BVUREM_TOK_in_builtinOp1433_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BVUREM_TOK_in_builtinOp1433	= { FOLLOW_BVUREM_TOK_in_builtinOp1433_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVSDIV_TOK_in_builtinOp1443  */
static	ANTLR3_BITWORD FOLLOW_BVSDIV_TOK_in_builtinOp1443_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BVSDIV_TOK_in_builtinOp1443	= { FOLLOW_BVSDIV_TOK_in_builtinOp1443_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVSREM_TOK_in_builtinOp1453  */
static	ANTLR3_BITWORD FOLLOW_BVSREM_TOK_in_builtinOp1453_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BVSREM_TOK_in_builtinOp1453	= { FOLLOW_BVSREM_TOK_in_builtinOp1453_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVSMOD_TOK_in_builtinOp1463  */
static	ANTLR3_BITWORD FOLLOW_BVSMOD_TOK_in_builtinOp1463_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BVSMOD_TOK_in_builtinOp1463	= { FOLLOW_BVSMOD_TOK_in_builtinOp1463_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVSHL_TOK_in_builtinOp1473  */
static	ANTLR3_BITWORD FOLLOW_BVSHL_TOK_in_builtinOp1473_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BVSHL_TOK_in_builtinOp1473	= { FOLLOW_BVSHL_TOK_in_builtinOp1473_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVLSHR_TOK_in_builtinOp1484  */
static	ANTLR3_BITWORD FOLLOW_BVLSHR_TOK_in_builtinOp1484_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BVLSHR_TOK_in_builtinOp1484	= { FOLLOW_BVLSHR_TOK_in_builtinOp1484_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVASHR_TOK_in_builtinOp1494  */
static	ANTLR3_BITWORD FOLLOW_BVASHR_TOK_in_builtinOp1494_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BVASHR_TOK_in_builtinOp1494	= { FOLLOW_BVASHR_TOK_in_builtinOp1494_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVULT_TOK_in_builtinOp1504  */
static	ANTLR3_BITWORD FOLLOW_BVULT_TOK_in_builtinOp1504_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BVULT_TOK_in_builtinOp1504	= { FOLLOW_BVULT_TOK_in_builtinOp1504_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVULE_TOK_in_builtinOp1515  */
static	ANTLR3_BITWORD FOLLOW_BVULE_TOK_in_builtinOp1515_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BVULE_TOK_in_builtinOp1515	= { FOLLOW_BVULE_TOK_in_builtinOp1515_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVUGT_TOK_in_builtinOp1526  */
static	ANTLR3_BITWORD FOLLOW_BVUGT_TOK_in_builtinOp1526_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BVUGT_TOK_in_builtinOp1526	= { FOLLOW_BVUGT_TOK_in_builtinOp1526_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVUGE_TOK_in_builtinOp1537  */
static	ANTLR3_BITWORD FOLLOW_BVUGE_TOK_in_builtinOp1537_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BVUGE_TOK_in_builtinOp1537	= { FOLLOW_BVUGE_TOK_in_builtinOp1537_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVSLT_TOK_in_builtinOp1548  */
static	ANTLR3_BITWORD FOLLOW_BVSLT_TOK_in_builtinOp1548_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BVSLT_TOK_in_builtinOp1548	= { FOLLOW_BVSLT_TOK_in_builtinOp1548_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVSLE_TOK_in_builtinOp1559  */
static	ANTLR3_BITWORD FOLLOW_BVSLE_TOK_in_builtinOp1559_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BVSLE_TOK_in_builtinOp1559	= { FOLLOW_BVSLE_TOK_in_builtinOp1559_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVSGT_TOK_in_builtinOp1570  */
static	ANTLR3_BITWORD FOLLOW_BVSGT_TOK_in_builtinOp1570_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BVSGT_TOK_in_builtinOp1570	= { FOLLOW_BVSGT_TOK_in_builtinOp1570_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVSGE_TOK_in_builtinOp1581  */
static	ANTLR3_BITWORD FOLLOW_BVSGE_TOK_in_builtinOp1581_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BVSGE_TOK_in_builtinOp1581	= { FOLLOW_BVSGE_TOK_in_builtinOp1581_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SELECT_TOK_in_builtinOp1595  */
static	ANTLR3_BITWORD FOLLOW_SELECT_TOK_in_builtinOp1595_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SELECT_TOK_in_builtinOp1595	= { FOLLOW_SELECT_TOK_in_builtinOp1595_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STORE_TOK_in_builtinOp1605  */
static	ANTLR3_BITWORD FOLLOW_STORE_TOK_in_builtinOp1605_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_STORE_TOK_in_builtinOp1605	= { FOLLOW_STORE_TOK_in_builtinOp1605_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_functionSymbol_in_parameterizedOperator1629  */
static	ANTLR3_BITWORD FOLLOW_functionSymbol_in_parameterizedOperator1629_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_functionSymbol_in_parameterizedOperator1629	= { FOLLOW_functionSymbol_in_parameterizedOperator1629_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bitVectorOperator_in_parameterizedOperator1636  */
static	ANTLR3_BITWORD FOLLOW_bitVectorOperator_in_parameterizedOperator1636_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_bitVectorOperator_in_parameterizedOperator1636	= { FOLLOW_bitVectorOperator_in_parameterizedOperator1636_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EXTRACT_TOK_in_bitVectorOperator1653  */
static	ANTLR3_BITWORD FOLLOW_EXTRACT_TOK_in_bitVectorOperator1653_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_EXTRACT_TOK_in_bitVectorOperator1653	= { FOLLOW_EXTRACT_TOK_in_bitVectorOperator1653_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_103_in_bitVectorOperator1655  */
static	ANTLR3_BITWORD FOLLOW_103_in_bitVectorOperator1655_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_103_in_bitVectorOperator1655	= { FOLLOW_103_in_bitVectorOperator1655_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMERAL_TOK_in_bitVectorOperator1661  */
static	ANTLR3_BITWORD FOLLOW_NUMERAL_TOK_in_bitVectorOperator1661_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000001000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMERAL_TOK_in_bitVectorOperator1661	= { FOLLOW_NUMERAL_TOK_in_bitVectorOperator1661_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_100_in_bitVectorOperator1663  */
static	ANTLR3_BITWORD FOLLOW_100_in_bitVectorOperator1663_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_100_in_bitVectorOperator1663	= { FOLLOW_100_in_bitVectorOperator1663_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMERAL_TOK_in_bitVectorOperator1669  */
static	ANTLR3_BITWORD FOLLOW_NUMERAL_TOK_in_bitVectorOperator1669_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000010000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMERAL_TOK_in_bitVectorOperator1669	= { FOLLOW_NUMERAL_TOK_in_bitVectorOperator1669_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_104_in_bitVectorOperator1671  */
static	ANTLR3_BITWORD FOLLOW_104_in_bitVectorOperator1671_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_104_in_bitVectorOperator1671	= { FOLLOW_104_in_bitVectorOperator1671_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_REPEAT_TOK_in_bitVectorOperator1683  */
static	ANTLR3_BITWORD FOLLOW_REPEAT_TOK_in_bitVectorOperator1683_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_REPEAT_TOK_in_bitVectorOperator1683	= { FOLLOW_REPEAT_TOK_in_bitVectorOperator1683_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_103_in_bitVectorOperator1685  */
static	ANTLR3_BITWORD FOLLOW_103_in_bitVectorOperator1685_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_103_in_bitVectorOperator1685	= { FOLLOW_103_in_bitVectorOperator1685_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMERAL_TOK_in_bitVectorOperator1691  */
static	ANTLR3_BITWORD FOLLOW_NUMERAL_TOK_in_bitVectorOperator1691_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000010000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMERAL_TOK_in_bitVectorOperator1691	= { FOLLOW_NUMERAL_TOK_in_bitVectorOperator1691_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_104_in_bitVectorOperator1693  */
static	ANTLR3_BITWORD FOLLOW_104_in_bitVectorOperator1693_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_104_in_bitVectorOperator1693	= { FOLLOW_104_in_bitVectorOperator1693_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ZERO_EXTEND_TOK_in_bitVectorOperator1705  */
static	ANTLR3_BITWORD FOLLOW_ZERO_EXTEND_TOK_in_bitVectorOperator1705_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ZERO_EXTEND_TOK_in_bitVectorOperator1705	= { FOLLOW_ZERO_EXTEND_TOK_in_bitVectorOperator1705_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_103_in_bitVectorOperator1707  */
static	ANTLR3_BITWORD FOLLOW_103_in_bitVectorOperator1707_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_103_in_bitVectorOperator1707	= { FOLLOW_103_in_bitVectorOperator1707_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMERAL_TOK_in_bitVectorOperator1713  */
static	ANTLR3_BITWORD FOLLOW_NUMERAL_TOK_in_bitVectorOperator1713_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000010000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMERAL_TOK_in_bitVectorOperator1713	= { FOLLOW_NUMERAL_TOK_in_bitVectorOperator1713_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_104_in_bitVectorOperator1715  */
static	ANTLR3_BITWORD FOLLOW_104_in_bitVectorOperator1715_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_104_in_bitVectorOperator1715	= { FOLLOW_104_in_bitVectorOperator1715_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SIGN_EXTEND_TOK_in_bitVectorOperator1727  */
static	ANTLR3_BITWORD FOLLOW_SIGN_EXTEND_TOK_in_bitVectorOperator1727_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_SIGN_EXTEND_TOK_in_bitVectorOperator1727	= { FOLLOW_SIGN_EXTEND_TOK_in_bitVectorOperator1727_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_103_in_bitVectorOperator1729  */
static	ANTLR3_BITWORD FOLLOW_103_in_bitVectorOperator1729_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_103_in_bitVectorOperator1729	= { FOLLOW_103_in_bitVectorOperator1729_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMERAL_TOK_in_bitVectorOperator1735  */
static	ANTLR3_BITWORD FOLLOW_NUMERAL_TOK_in_bitVectorOperator1735_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000010000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMERAL_TOK_in_bitVectorOperator1735	= { FOLLOW_NUMERAL_TOK_in_bitVectorOperator1735_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_104_in_bitVectorOperator1737  */
static	ANTLR3_BITWORD FOLLOW_104_in_bitVectorOperator1737_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_104_in_bitVectorOperator1737	= { FOLLOW_104_in_bitVectorOperator1737_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ROTATE_LEFT_TOK_in_bitVectorOperator1749  */
static	ANTLR3_BITWORD FOLLOW_ROTATE_LEFT_TOK_in_bitVectorOperator1749_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ROTATE_LEFT_TOK_in_bitVectorOperator1749	= { FOLLOW_ROTATE_LEFT_TOK_in_bitVectorOperator1749_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_103_in_bitVectorOperator1751  */
static	ANTLR3_BITWORD FOLLOW_103_in_bitVectorOperator1751_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_103_in_bitVectorOperator1751	= { FOLLOW_103_in_bitVectorOperator1751_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMERAL_TOK_in_bitVectorOperator1757  */
static	ANTLR3_BITWORD FOLLOW_NUMERAL_TOK_in_bitVectorOperator1757_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000010000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMERAL_TOK_in_bitVectorOperator1757	= { FOLLOW_NUMERAL_TOK_in_bitVectorOperator1757_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_104_in_bitVectorOperator1759  */
static	ANTLR3_BITWORD FOLLOW_104_in_bitVectorOperator1759_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_104_in_bitVectorOperator1759	= { FOLLOW_104_in_bitVectorOperator1759_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ROTATE_RIGHT_TOK_in_bitVectorOperator1771  */
static	ANTLR3_BITWORD FOLLOW_ROTATE_RIGHT_TOK_in_bitVectorOperator1771_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ROTATE_RIGHT_TOK_in_bitVectorOperator1771	= { FOLLOW_ROTATE_RIGHT_TOK_in_bitVectorOperator1771_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_103_in_bitVectorOperator1773  */
static	ANTLR3_BITWORD FOLLOW_103_in_bitVectorOperator1773_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_103_in_bitVectorOperator1773	= { FOLLOW_103_in_bitVectorOperator1773_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMERAL_TOK_in_bitVectorOperator1779  */
static	ANTLR3_BITWORD FOLLOW_NUMERAL_TOK_in_bitVectorOperator1779_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000010000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMERAL_TOK_in_bitVectorOperator1779	= { FOLLOW_NUMERAL_TOK_in_bitVectorOperator1779_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_104_in_bitVectorOperator1781  */
static	ANTLR3_BITWORD FOLLOW_104_in_bitVectorOperator1781_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_104_in_bitVectorOperator1781	= { FOLLOW_104_in_bitVectorOperator1781_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_functionName_in_predicateName1804  */
static	ANTLR3_BITWORD FOLLOW_functionName_in_predicateName1804_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_functionName_in_predicateName1804	= { FOLLOW_functionName_in_predicateName1804_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_identifier_in_functionName1822  */
static	ANTLR3_BITWORD FOLLOW_identifier_in_functionName1822_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_identifier_in_functionName1822	= { FOLLOW_identifier_in_functionName1822_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_functionName_in_functionSymbol1844  */
static	ANTLR3_BITWORD FOLLOW_functionName_in_functionSymbol1844_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_functionName_in_functionSymbol1844	= { FOLLOW_functionName_in_functionSymbol1844_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ATTR_IDENTIFIER_in_attribute1867  */
static	ANTLR3_BITWORD FOLLOW_ATTR_IDENTIFIER_in_attribute1867_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ATTR_IDENTIFIER_in_attribute1867	= { FOLLOW_ATTR_IDENTIFIER_in_attribute1867_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_functionDeclaration1892  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_functionDeclaration1892_bits[]	= { ANTLR3_UINT64_LIT(0x1000000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_functionDeclaration1892	= { FOLLOW_LPAREN_TOK_in_functionDeclaration1892_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_functionName_in_functionDeclaration1894  */
static	ANTLR3_BITWORD FOLLOW_functionName_in_functionDeclaration1894_bits[]	= { ANTLR3_UINT64_LIT(0x1000000000002000), ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_functionName_in_functionDeclaration1894	= { FOLLOW_functionName_in_functionDeclaration1894_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortSymbol_in_functionDeclaration1907  */
static	ANTLR3_BITWORD FOLLOW_sortSymbol_in_functionDeclaration1907_bits[]	= { ANTLR3_UINT64_LIT(0x1000000000002000), ANTLR3_UINT64_LIT(0x0000004000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_sortSymbol_in_functionDeclaration1907	= { FOLLOW_sortSymbol_in_functionDeclaration1907_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortList_in_functionDeclaration1922  */
static	ANTLR3_BITWORD FOLLOW_sortList_in_functionDeclaration1922_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_sortList_in_functionDeclaration1922	= { FOLLOW_sortList_in_functionDeclaration1922_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_functionDeclaration1925  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_functionDeclaration1925_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_functionDeclaration1925	= { FOLLOW_RPAREN_TOK_in_functionDeclaration1925_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_predicateDeclaration1952  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_predicateDeclaration1952_bits[]	= { ANTLR3_UINT64_LIT(0x1000000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_predicateDeclaration1952	= { FOLLOW_LPAREN_TOK_in_predicateDeclaration1952_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_predicateName_in_predicateDeclaration1954  */
static	ANTLR3_BITWORD FOLLOW_predicateName_in_predicateDeclaration1954_bits[]	= { ANTLR3_UINT64_LIT(0x1000000000002000), ANTLR3_UINT64_LIT(0x0000004000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_predicateName_in_predicateDeclaration1954	= { FOLLOW_predicateName_in_predicateDeclaration1954_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortList_in_predicateDeclaration1957  */
static	ANTLR3_BITWORD FOLLOW_sortList_in_predicateDeclaration1957_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_sortList_in_predicateDeclaration1957	= { FOLLOW_sortList_in_predicateDeclaration1957_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_predicateDeclaration1960  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_predicateDeclaration1960_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_predicateDeclaration1960	= { FOLLOW_RPAREN_TOK_in_predicateDeclaration1960_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortName_in_sortDeclaration1985  */
static	ANTLR3_BITWORD FOLLOW_sortName_in_sortDeclaration1985_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sortName_in_sortDeclaration1985	= { FOLLOW_sortName_in_sortDeclaration1985_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortSymbol_in_sortList2014  */
static	ANTLR3_BITWORD FOLLOW_sortSymbol_in_sortList2014_bits[]	= { ANTLR3_UINT64_LIT(0x1000000000002002), ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sortSymbol_in_sortList2014	= { FOLLOW_sortSymbol_in_sortList2014_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_identifier_in_sortName2034  */
static	ANTLR3_BITWORD FOLLOW_identifier_in_sortName2034_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_identifier_in_sortName2034	= { FOLLOW_identifier_in_sortName2034_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortName_in_sortSymbol2057  */
static	ANTLR3_BITWORD FOLLOW_sortName_in_sortSymbol2057_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sortName_in_sortSymbol2057	= { FOLLOW_sortName_in_sortSymbol2057_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BITVECTOR_TOK_in_sortSymbol2069  */
static	ANTLR3_BITWORD FOLLOW_BITVECTOR_TOK_in_sortSymbol2069_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_BITVECTOR_TOK_in_sortSymbol2069	= { FOLLOW_BITVECTOR_TOK_in_sortSymbol2069_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_103_in_sortSymbol2071  */
static	ANTLR3_BITWORD FOLLOW_103_in_sortSymbol2071_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_103_in_sortSymbol2071	= { FOLLOW_103_in_sortSymbol2071_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMERAL_TOK_in_sortSymbol2073  */
static	ANTLR3_BITWORD FOLLOW_NUMERAL_TOK_in_sortSymbol2073_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000010000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMERAL_TOK_in_sortSymbol2073	= { FOLLOW_NUMERAL_TOK_in_sortSymbol2073_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_104_in_sortSymbol2075  */
static	ANTLR3_BITWORD FOLLOW_104_in_sortSymbol2075_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_104_in_sortSymbol2075	= { FOLLOW_104_in_sortSymbol2075_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_102_in_sortSymbol2087  */
static	ANTLR3_BITWORD FOLLOW_102_in_sortSymbol2087_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_102_in_sortSymbol2087	= { FOLLOW_102_in_sortSymbol2087_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMERAL_TOK_in_sortSymbol2091  */
static	ANTLR3_BITWORD FOLLOW_NUMERAL_TOK_in_sortSymbol2091_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000001000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMERAL_TOK_in_sortSymbol2091	= { FOLLOW_NUMERAL_TOK_in_sortSymbol2091_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_100_in_sortSymbol2093  */
static	ANTLR3_BITWORD FOLLOW_100_in_sortSymbol2093_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_100_in_sortSymbol2093	= { FOLLOW_100_in_sortSymbol2093_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMERAL_TOK_in_sortSymbol2097  */
static	ANTLR3_BITWORD FOLLOW_NUMERAL_TOK_in_sortSymbol2097_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000010000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMERAL_TOK_in_sortSymbol2097	= { FOLLOW_NUMERAL_TOK_in_sortSymbol2097_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_104_in_sortSymbol2099  */
static	ANTLR3_BITWORD FOLLOW_104_in_sortSymbol2099_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_104_in_sortSymbol2099	= { FOLLOW_104_in_sortSymbol2099_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SAT_TOK_in_status2117  */
static	ANTLR3_BITWORD FOLLOW_SAT_TOK_in_status2117_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SAT_TOK_in_status2117	= { FOLLOW_SAT_TOK_in_status2117_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_UNSAT_TOK_in_status2131  */
static	ANTLR3_BITWORD FOLLOW_UNSAT_TOK_in_status2131_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_UNSAT_TOK_in_status2131	= { FOLLOW_UNSAT_TOK_in_status2131_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_UNKNOWN_TOK_in_status2143  */
static	ANTLR3_BITWORD FOLLOW_UNKNOWN_TOK_in_status2143_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_UNKNOWN_TOK_in_status2143	= { FOLLOW_UNKNOWN_TOK_in_status2143_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PATTERN_ANNOTATION_BEGIN_in_annotation2168  */
static	ANTLR3_BITWORD FOLLOW_PATTERN_ANNOTATION_BEGIN_in_annotation2168_bits[]	= { ANTLR3_UINT64_LIT(0x10C0000000001800), ANTLR3_UINT64_LIT(0x0000000020008112) };
static  ANTLR3_BITSET_LIST FOLLOW_PATTERN_ANNOTATION_BEGIN_in_annotation2168	= { FOLLOW_PATTERN_ANNOTATION_BEGIN_in_annotation2168_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_annotatedFormulas_in_annotation2180  */
static	ANTLR3_BITWORD FOLLOW_annotatedFormulas_in_annotation2180_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000020000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_annotatedFormulas_in_annotation2180	= { FOLLOW_annotatedFormulas_in_annotation2180_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_105_in_annotation2183  */
static	ANTLR3_BITWORD FOLLOW_105_in_annotation2183_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_105_in_annotation2183	= { FOLLOW_105_in_annotation2183_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_attribute_in_annotation2189  */
static	ANTLR3_BITWORD FOLLOW_attribute_in_annotation2189_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_attribute_in_annotation2189	= { FOLLOW_attribute_in_annotation2189_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_userValue_in_annotation2198  */
static	ANTLR3_BITWORD FOLLOW_userValue_in_annotation2198_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_userValue_in_annotation2198	= { FOLLOW_userValue_in_annotation2198_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PATTERN_ANNOTATION_BEGIN_in_termAnnotation2242  */
static	ANTLR3_BITWORD FOLLOW_PATTERN_ANNOTATION_BEGIN_in_termAnnotation2242_bits[]	= { ANTLR3_UINT64_LIT(0x10C0000000001800), ANTLR3_UINT64_LIT(0x0000000020008112) };
static  ANTLR3_BITSET_LIST FOLLOW_PATTERN_ANNOTATION_BEGIN_in_termAnnotation2242	= { FOLLOW_PATTERN_ANNOTATION_BEGIN_in_termAnnotation2242_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_annotatedFormulas_in_termAnnotation2244  */
static	ANTLR3_BITWORD FOLLOW_annotatedFormulas_in_termAnnotation2244_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000020000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_annotatedFormulas_in_termAnnotation2244	= { FOLLOW_annotatedFormulas_in_termAnnotation2244_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_105_in_termAnnotation2247  */
static	ANTLR3_BITWORD FOLLOW_105_in_termAnnotation2247_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_105_in_termAnnotation2247	= { FOLLOW_105_in_termAnnotation2247_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_101_in_termAnnotation2259  */
static	ANTLR3_BITWORD FOLLOW_101_in_termAnnotation2259_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_101_in_termAnnotation2259	= { FOLLOW_101_in_termAnnotation2259_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_attribute_in_termAnnotation2271  */
static	ANTLR3_BITWORD FOLLOW_attribute_in_termAnnotation2271_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_attribute_in_termAnnotation2271	= { FOLLOW_attribute_in_termAnnotation2271_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_userValue_in_termAnnotation2274  */
static	ANTLR3_BITWORD FOLLOW_userValue_in_termAnnotation2274_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_userValue_in_termAnnotation2274	= { FOLLOW_userValue_in_termAnnotation2274_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_identifier2298  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_identifier2298_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_identifier2298	= { FOLLOW_IDENTIFIER_in_identifier2298_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LET_IDENTIFIER_in_let_identifier2320  */
static	ANTLR3_BITWORD FOLLOW_LET_IDENTIFIER_in_let_identifier2320_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_LET_IDENTIFIER_in_let_identifier2320	= { FOLLOW_LET_IDENTIFIER_in_let_identifier2320_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FLET_IDENTIFIER_in_flet_identifier2342  */
static	ANTLR3_BITWORD FOLLOW_FLET_IDENTIFIER_in_flet_identifier2342_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_FLET_IDENTIFIER_in_flet_identifier2342	= { FOLLOW_FLET_IDENTIFIER_in_flet_identifier2342_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_USER_VALUE_in_userValue3590  */
static	ANTLR3_BITWORD FOLLOW_USER_VALUE_in_userValue3590_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_USER_VALUE_in_userValue3590	= { FOLLOW_USER_VALUE_in_userValue3590_bits, 1	};


/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start parseExpr
 * /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:136:1: parseExpr returns [CVC4::parser::smt1::myExpr expr] : ( annotatedFormula[expr] | EOF );
 */
static CVC4::parser::smt1::myExpr
parseExpr(pSmt1Parser ctx)
{
    CVC4::parser::smt1::myExpr expr;


    /* Initialize rule variables
     */

    {
        {
            //  /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:137:3: ( annotatedFormula[expr] | EOF )

            ANTLR3_UINT32 alt1;

            alt1=2;

            switch ( LA(1) )
            {
            case BITVECTOR1_BV_CONST:
            case BITVECTOR_BV_CONST:
            case FALSE_TOK:
            case FLET_IDENTIFIER:
            case IDENTIFIER:
            case LET_IDENTIFIER:
            case LPAREN_TOK:
            case NUMERAL_TOK:
            case RATIONAL_TOK:
            case TRUE_TOK:
            	{
            		alt1=1;
            	}
                break;
            case EOF:
            	{
            		alt1=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 1;
                EXCEPTION->state        = 0;


                goto ruleparseExprEx;

            }

            switch (alt1)
            {
        	case 1:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:137:5: annotatedFormula[expr]
        	    {
        	        FOLLOWPUSH(FOLLOW_annotatedFormula_in_parseExpr105);
        	        annotatedFormula(ctx, expr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseExprEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:138:5: EOF
        	    {
        	         MATCHT(EOF, &FOLLOW_EOF_in_parseExpr112);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseExprEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleparseExprEx; /* Prevent compiler warnings */
    ruleparseExprEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return expr;
}
/* $ANTLR end parseExpr */

/**
 * $ANTLR start parseCommand
 * /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:145:1: parseCommand returns [CVC4::Command* cmd = NULL] : (b= benchmark | LPAREN_TOK c= IDENTIFIER );
 */
static CVC4::Command*
parseCommand(pSmt1Parser ctx)
{
    CVC4::Command* cmd;


    pANTLR3_COMMON_TOKEN    c;
    CVC4::Command* b;
    #undef	RETURN_TYPE_b
    #define	RETURN_TYPE_b CVC4::Command*

    /* Initialize rule variables
     */
    cmd =  NULL;


    c       = NULL;

    {
        {
            //  /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:146:3: (b= benchmark | LPAREN_TOK c= IDENTIFIER )

            ANTLR3_UINT32 alt2;

            alt2=2;

            switch ( LA(1) )
            {
            case LPAREN_TOK:
            	{
            		switch ( LA(2) )
            		{
            		case BENCHMARK_TOK:
            			{
            				alt2=1;
            			}
            		    break;
            		case IDENTIFIER:
            			{
            				alt2=2;
            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 2;
            		    EXCEPTION->state        = 1;


            		    goto ruleparseCommandEx;

            		}

            	}
                break;
            case EOF:
            	{
            		alt2=1;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 2;
                EXCEPTION->state        = 0;


                goto ruleparseCommandEx;

            }

            switch (alt2)
            {
        	case 1:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:146:5: b= benchmark
        	    {
        	        FOLLOWPUSH(FOLLOW_benchmark_in_parseCommand135);
        	        b=benchmark(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseCommandEx;
        	        }


        	        {
        	             cmd= b;
        	             
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:147:5: LPAREN_TOK c= IDENTIFIER
        	    {
        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_parseCommand143);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseCommandEx;
        	        }


        	        c = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_parseCommand147);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseCommandEx;
        	        }


        	        {
        	             std::string s = AntlrInput::tokenText(c);
        	                  if(s == "set" || s == "get") {
        	                    PARSER_STATE->parseError(std::string("In SMT-LIBv1 mode, expected keyword `benchmark', but it looks like you're writing SMT-LIBv2.  Use --lang smt for SMT-LIBv2."));
        	                  } else {
        	                    PARSER_STATE->parseError(std::string("expected keyword `benchmark', got `" + s + "'"));
        	                  }
        	                
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleparseCommandEx; /* Prevent compiler warnings */
    ruleparseCommandEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return cmd;
}
/* $ANTLR end parseCommand */

/**
 * $ANTLR start benchmark
 * /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:161:1: benchmark returns [CVC4::Command* cmd = NULL] : ( LPAREN_TOK BENCHMARK_TOK IDENTIFIER c= benchAttributes RPAREN_TOK | EOF );
 */
static CVC4::Command*
benchmark(pSmt1Parser ctx)
{
    CVC4::Command* cmd;


    CVC4::CommandSequence* c;
    #undef	RETURN_TYPE_c
    #define	RETURN_TYPE_c CVC4::CommandSequence*

    /* Initialize rule variables
     */
    cmd =  NULL;


    {
        {
            //  /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:162:3: ( LPAREN_TOK BENCHMARK_TOK IDENTIFIER c= benchAttributes RPAREN_TOK | EOF )

            ANTLR3_UINT32 alt3;

            alt3=2;

            switch ( LA(1) )
            {
            case LPAREN_TOK:
            	{
            		alt3=1;
            	}
                break;
            case EOF:
            	{
            		alt3=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 3;
                EXCEPTION->state        = 0;


                goto rulebenchmarkEx;

            }

            switch (alt3)
            {
        	case 1:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:162:5: LPAREN_TOK BENCHMARK_TOK IDENTIFIER c= benchAttributes RPAREN_TOK
        	    {
        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_benchmark172);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebenchmarkEx;
        	        }


        	         MATCHT(BENCHMARK_TOK, &FOLLOW_BENCHMARK_TOK_in_benchmark174);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebenchmarkEx;
        	        }


        	         MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_benchmark176);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebenchmarkEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_benchAttributes_in_benchmark182);
        	        c=benchAttributes(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebenchmarkEx;
        	        }


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_benchmark184);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebenchmarkEx;
        	        }


        	        {
        	             cmd= c;
        	             
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:164:5: EOF
        	    {
        	         MATCHT(EOF, &FOLLOW_EOF_in_benchmark195);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebenchmarkEx;
        	        }


        	        {
        	             cmd= 0;
        	             
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulebenchmarkEx; /* Prevent compiler warnings */
    rulebenchmarkEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return cmd;
}
/* $ANTLR end benchmark */

/**
 * $ANTLR start benchAttributes
 * /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:172:1: benchAttributes returns [CVC4::CommandSequence* cmd_seq = NULL] : (cmd= benchAttribute )+ ;
 */
static CVC4::CommandSequence*
benchAttributes(pSmt1Parser ctx)
{
    CVC4::CommandSequence* cmd_seq;


    CVC4::Command* cmd;
    #undef	RETURN_TYPE_cmd
    #define	RETURN_TYPE_cmd CVC4::Command*

    /* Initialize rule variables
     */
    cmd_seq =  NULL;



      cmd_seq = new CommandSequence();

    {
        // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:176:3: ( (cmd= benchAttribute )+ )
        // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:176:5: (cmd= benchAttribute )+
        {
            // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:176:5: (cmd= benchAttribute )+
            {
                int cnt4=0;

                for (;;)
                {
                    int alt4=2;
            	switch ( LA(1) )
            	{
            	case ASSUMPTION_TOK:
            	case ATTR_IDENTIFIER:
            	case EXTRAFUNS_TOK:
            	case EXTRAPREDS_TOK:
            	case EXTRASORTS_TOK:
            	case FORMULA_TOK:
            	case LOGIC_TOK:
            	case NOTES_TOK:
            	case PATTERN_ANNOTATION_BEGIN:
            	case STATUS_TOK:
            		{
            			alt4=1;
            		}
            	    break;

            	}

            	switch (alt4)
            	{
            	    case 1:
            	        // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:176:6: cmd= benchAttribute
            	        {
            	            FOLLOWPUSH(FOLLOW_benchAttribute_in_benchAttributes226);
            	            cmd=benchAttribute(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulebenchAttributesEx;
            	            }


            	            {
            	                 if (cmd) cmd_seq->addCommand(cmd); 
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt4 >= 1 )
            		{
            		    goto loop4;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulebenchAttributesEx;
            	}
            	cnt4++;
                }
                loop4: ;	/* Jump to here if this rule does not match */
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulebenchAttributesEx; /* Prevent compiler warnings */
    rulebenchAttributesEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return cmd_seq;
}
/* $ANTLR end benchAttributes */

/**
 * $ANTLR start benchAttribute
 * /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:184:1: benchAttribute returns [CVC4::Command* smt_command = NULL] : ( LOGIC_TOK identifier[name,CHECK_NONE,SYM_VARIABLE] | ASSUMPTION_TOK annotatedFormula[expr] | FORMULA_TOK annotatedFormula[expr] | STATUS_TOK status[b_status] | EXTRAFUNS_TOK LPAREN_TOK ( functionDeclaration[c] )+ RPAREN_TOK | EXTRAPREDS_TOK LPAREN_TOK ( predicateDeclaration[c] )+ RPAREN_TOK | EXTRASORTS_TOK LPAREN_TOK ( sortDeclaration[c] )+ RPAREN_TOK | NOTES_TOK STRING_LITERAL | annotation[smt_command] );
 */
static CVC4::Command*
benchAttribute(pSmt1Parser ctx)
{
    CVC4::Command* smt_command;



      std::string name;
      BenchmarkStatus b_status;
      Expr expr;
      Command* c;

    pANTLR3_COMMON_TOKEN    STRING_LITERAL1;

    /* Initialize rule variables
     */
    smt_command =  NULL;


    STRING_LITERAL1       = NULL;

    {
        {
            //  /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:191:3: ( LOGIC_TOK identifier[name,CHECK_NONE,SYM_VARIABLE] | ASSUMPTION_TOK annotatedFormula[expr] | FORMULA_TOK annotatedFormula[expr] | STATUS_TOK status[b_status] | EXTRAFUNS_TOK LPAREN_TOK ( functionDeclaration[c] )+ RPAREN_TOK | EXTRAPREDS_TOK LPAREN_TOK ( predicateDeclaration[c] )+ RPAREN_TOK | EXTRASORTS_TOK LPAREN_TOK ( sortDeclaration[c] )+ RPAREN_TOK | NOTES_TOK STRING_LITERAL | annotation[smt_command] )

            ANTLR3_UINT32 alt8;

            alt8=9;

            switch ( LA(1) )
            {
            case LOGIC_TOK:
            	{
            		alt8=1;
            	}
                break;
            case ASSUMPTION_TOK:
            	{
            		alt8=2;
            	}
                break;
            case FORMULA_TOK:
            	{
            		alt8=3;
            	}
                break;
            case STATUS_TOK:
            	{
            		alt8=4;
            	}
                break;
            case EXTRAFUNS_TOK:
            	{
            		alt8=5;
            	}
                break;
            case EXTRAPREDS_TOK:
            	{
            		alt8=6;
            	}
                break;
            case EXTRASORTS_TOK:
            	{
            		alt8=7;
            	}
                break;
            case NOTES_TOK:
            	{
            		alt8=8;
            	}
                break;
            case ATTR_IDENTIFIER:
            case PATTERN_ANNOTATION_BEGIN:
            	{
            		alt8=9;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 8;
                EXCEPTION->state        = 0;


                goto rulebenchAttributeEx;

            }

            switch (alt8)
            {
        	case 1:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:191:5: LOGIC_TOK identifier[name,CHECK_NONE,SYM_VARIABLE]
        	    {
        	         MATCHT(LOGIC_TOK, &FOLLOW_LOGIC_TOK_in_benchAttribute255);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebenchAttributeEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_identifier_in_benchAttribute257);
        	        identifier(ctx, name, CHECK_NONE, SYM_VARIABLE);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebenchAttributeEx;
        	        }


        	        {
        	             PARSER_STATE->preemptCommand(new SetBenchmarkLogicCommand(name));
        	                  PARSER_STATE->setLogic(name);
        	                  smt_command = new EmptyCommand();
        	                
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:196:5: ASSUMPTION_TOK annotatedFormula[expr]
        	    {
        	         MATCHT(ASSUMPTION_TOK, &FOLLOW_ASSUMPTION_TOK_in_benchAttribute270);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebenchAttributeEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_annotatedFormula_in_benchAttribute272);
        	        annotatedFormula(ctx, expr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebenchAttributeEx;
        	        }


        	        {
        	             smt_command = new AssertCommand(expr); 
        	        }


        	    }
        	    break;
        	case 3:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:198:5: FORMULA_TOK annotatedFormula[expr]
        	    {
        	         MATCHT(FORMULA_TOK, &FOLLOW_FORMULA_TOK_in_benchAttribute285);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebenchAttributeEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_annotatedFormula_in_benchAttribute287);
        	        annotatedFormula(ctx, expr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebenchAttributeEx;
        	        }


        	        {
        	             smt_command = new CheckSatCommand(expr); 
        	        }


        	    }
        	    break;
        	case 4:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:200:5: STATUS_TOK status[b_status]
        	    {
        	         MATCHT(STATUS_TOK, &FOLLOW_STATUS_TOK_in_benchAttribute300);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebenchAttributeEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_status_in_benchAttribute302);
        	        status(ctx, b_status);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebenchAttributeEx;
        	        }


        	        {
        	             smt_command = new SetBenchmarkStatusCommand(b_status); 
        	        }


        	    }
        	    break;
        	case 5:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:202:5: EXTRAFUNS_TOK LPAREN_TOK ( functionDeclaration[c] )+ RPAREN_TOK
        	    {
        	         MATCHT(EXTRAFUNS_TOK, &FOLLOW_EXTRAFUNS_TOK_in_benchAttribute315);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebenchAttributeEx;
        	        }


        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_benchAttribute317);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebenchAttributeEx;
        	        }


        	        {
        	             smt_command = new CommandSequence(); 
        	        }


        	        // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:204:5: ( functionDeclaration[c] )+
        	        {
        	            int cnt5=0;

        	            for (;;)
        	            {
        	                int alt5=2;
        	        	switch ( LA(1) )
        	        	{
        	        	case LPAREN_TOK:
        	        		{
        	        			alt5=1;
        	        		}
        	        	    break;

        	        	}

        	        	switch (alt5)
        	        	{
        	        	    case 1:
        	        	        // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:204:7: functionDeclaration[c]
        	        	        {
        	        	            FOLLOWPUSH(FOLLOW_functionDeclaration_in_benchAttribute331);
        	        	            functionDeclaration(ctx, c);

        	        	            FOLLOWPOP();
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto rulebenchAttributeEx;
        	        	            }


        	        	            {
        	        	                 ((CommandSequence*) smt_command)->addCommand(c); 
        	        	            }


        	        	        }
        	        	        break;

        	        	    default:

        	        		if ( cnt5 >= 1 )
        	        		{
        	        		    goto loop5;
        	        		}
        	        		/* mismatchedSetEx()
        	        		 */
        	        		CONSTRUCTEX();
        	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        	        		goto rulebenchAttributeEx;
        	        	}
        	        	cnt5++;
        	            }
        	            loop5: ;	/* Jump to here if this rule does not match */
        	        }

        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_benchAttribute349);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebenchAttributeEx;
        	        }


        	    }
        	    break;
        	case 6:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:207:5: EXTRAPREDS_TOK LPAREN_TOK ( predicateDeclaration[c] )+ RPAREN_TOK
        	    {
        	         MATCHT(EXTRAPREDS_TOK, &FOLLOW_EXTRAPREDS_TOK_in_benchAttribute355);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebenchAttributeEx;
        	        }


        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_benchAttribute357);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebenchAttributeEx;
        	        }


        	        // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:208:5: ( predicateDeclaration[c] )+
        	        {
        	            int cnt6=0;

        	            for (;;)
        	            {
        	                int alt6=2;
        	        	switch ( LA(1) )
        	        	{
        	        	case LPAREN_TOK:
        	        		{
        	        			alt6=1;
        	        		}
        	        	    break;

        	        	}

        	        	switch (alt6)
        	        	{
        	        	    case 1:
        	        	        // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:208:7: predicateDeclaration[c]
        	        	        {
        	        	            {
        	        	                 smt_command = new CommandSequence(); 
        	        	            }


        	        	            FOLLOWPUSH(FOLLOW_predicateDeclaration_in_benchAttribute373);
        	        	            predicateDeclaration(ctx, c);

        	        	            FOLLOWPOP();
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto rulebenchAttributeEx;
        	        	            }


        	        	            {
        	        	                 ((CommandSequence*) smt_command)->addCommand(c); 
        	        	            }


        	        	        }
        	        	        break;

        	        	    default:

        	        		if ( cnt6 >= 1 )
        	        		{
        	        		    goto loop6;
        	        		}
        	        		/* mismatchedSetEx()
        	        		 */
        	        		CONSTRUCTEX();
        	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        	        		goto rulebenchAttributeEx;
        	        	}
        	        	cnt6++;
        	            }
        	            loop6: ;	/* Jump to here if this rule does not match */
        	        }

        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_benchAttribute391);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebenchAttributeEx;
        	        }


        	    }
        	    break;
        	case 7:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:212:5: EXTRASORTS_TOK LPAREN_TOK ( sortDeclaration[c] )+ RPAREN_TOK
        	    {
        	         MATCHT(EXTRASORTS_TOK, &FOLLOW_EXTRASORTS_TOK_in_benchAttribute397);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebenchAttributeEx;
        	        }


        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_benchAttribute399);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebenchAttributeEx;
        	        }


        	        // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:213:5: ( sortDeclaration[c] )+
        	        {
        	            int cnt7=0;

        	            for (;;)
        	            {
        	                int alt7=2;
        	        	switch ( LA(1) )
        	        	{
        	        	case IDENTIFIER:
        	        		{
        	        			alt7=1;
        	        		}
        	        	    break;

        	        	}

        	        	switch (alt7)
        	        	{
        	        	    case 1:
        	        	        // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:213:7: sortDeclaration[c]
        	        	        {
        	        	            {
        	        	                 smt_command = new CommandSequence(); 
        	        	            }


        	        	            FOLLOWPUSH(FOLLOW_sortDeclaration_in_benchAttribute415);
        	        	            sortDeclaration(ctx, c);

        	        	            FOLLOWPOP();
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto rulebenchAttributeEx;
        	        	            }


        	        	            {
        	        	                 ((CommandSequence*) smt_command)->addCommand(c); 
        	        	            }


        	        	        }
        	        	        break;

        	        	    default:

        	        		if ( cnt7 >= 1 )
        	        		{
        	        		    goto loop7;
        	        		}
        	        		/* mismatchedSetEx()
        	        		 */
        	        		CONSTRUCTEX();
        	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        	        		goto rulebenchAttributeEx;
        	        	}
        	        	cnt7++;
        	            }
        	            loop7: ;	/* Jump to here if this rule does not match */
        	        }

        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_benchAttribute433);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebenchAttributeEx;
        	        }


        	    }
        	    break;
        	case 8:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:217:5: NOTES_TOK STRING_LITERAL
        	    {
        	         MATCHT(NOTES_TOK, &FOLLOW_NOTES_TOK_in_benchAttribute439);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebenchAttributeEx;
        	        }


        	        STRING_LITERAL1 = (pANTLR3_COMMON_TOKEN) MATCHT(STRING_LITERAL, &FOLLOW_STRING_LITERAL_in_benchAttribute441);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebenchAttributeEx;
        	        }


        	        {
        	             smt_command = new CommentCommand(AntlrInput::tokenText(STRING_LITERAL1)); 
        	        }


        	    }
        	    break;
        	case 9:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:219:5: annotation[smt_command]
        	    {
        	        FOLLOWPUSH(FOLLOW_annotation_in_benchAttribute453);
        	        annotation(ctx, smt_command);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebenchAttributeEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulebenchAttributeEx; /* Prevent compiler warnings */
    rulebenchAttributeEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return smt_command;
}
/* $ANTLR end benchAttribute */

/**
 * $ANTLR start annotatedFormula
 * /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:226:1: annotatedFormula[CVC4::Expr& expr] : ( LPAREN_TOK builtinOp[kind] annotatedFormulas[args,expr] ( termAnnotation[expr] )* RPAREN_TOK | LPAREN_TOK ( FORALL_TOK | EXISTS_TOK ) ( LPAREN_TOK let_identifier[name,CHECK_NONE] t= sortSymbol RPAREN_TOK )+ annotatedFormula[expr] ( termAnnotation[expr] )* RPAREN_TOK | LPAREN_TOK parameterizedOperator[op] annotatedFormulas[args,expr] ( termAnnotation[expr] )* RPAREN_TOK | LPAREN_TOK ITE_TOK annotatedFormula[expr] annotatedFormula[expr] annotatedFormula[expr] ( termAnnotation[expr] )* RPAREN_TOK | LPAREN_TOK ( LET_TOK LPAREN_TOK let_identifier[name,CHECK_UNDECLARED] | FLET_TOK LPAREN_TOK flet_identifier[name,CHECK_UNDECLARED] ) annotatedFormula[expr] RPAREN_TOK annotatedFormula[expr] ( termAnnotation[expr] )* RPAREN_TOK | TRUE_TOK | FALSE_TOK | NUMERAL_TOK | RATIONAL_TOK |n= BITVECTOR_BV_CONST '[' size= NUMERAL_TOK ']' |n= BITVECTOR1_BV_CONST | ( identifier[name,CHECK_DECLARED,SYM_VARIABLE] | let_identifier[name,CHECK_DECLARED] | flet_identifier[name,CHECK_DECLARED] ) );
 */
static void
annotatedFormula(pSmt1Parser ctx, CVC4::Expr& expr)
{
    pANTLR3_COMMON_TOKEN    n;
    pANTLR3_COMMON_TOKEN    size;
    pANTLR3_COMMON_TOKEN    NUMERAL_TOK2;
    pANTLR3_COMMON_TOKEN    RATIONAL_TOK3;
    CVC4::parser::smt1::myType t;
    #undef	RETURN_TYPE_t
    #define	RETURN_TYPE_t CVC4::parser::smt1::myType

    /* Initialize rule variables
     */


      Debug("parser") << "annotated formula: " << AntlrInput::tokenText(LT(1)) << std::endl;
      Kind kind;
      std::string name;
      std::vector<Expr> args; /* = getExprVector(); */
      std::vector<Expr> args2;
      Expr op; /* Operator expression FIXME: move away kill it */

    n       = NULL;
    size       = NULL;
    NUMERAL_TOK2       = NULL;
    RATIONAL_TOK3       = NULL;

    {
        {
            //  /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:235:3: ( LPAREN_TOK builtinOp[kind] annotatedFormulas[args,expr] ( termAnnotation[expr] )* RPAREN_TOK | LPAREN_TOK ( FORALL_TOK | EXISTS_TOK ) ( LPAREN_TOK let_identifier[name,CHECK_NONE] t= sortSymbol RPAREN_TOK )+ annotatedFormula[expr] ( termAnnotation[expr] )* RPAREN_TOK | LPAREN_TOK parameterizedOperator[op] annotatedFormulas[args,expr] ( termAnnotation[expr] )* RPAREN_TOK | LPAREN_TOK ITE_TOK annotatedFormula[expr] annotatedFormula[expr] annotatedFormula[expr] ( termAnnotation[expr] )* RPAREN_TOK | LPAREN_TOK ( LET_TOK LPAREN_TOK let_identifier[name,CHECK_UNDECLARED] | FLET_TOK LPAREN_TOK flet_identifier[name,CHECK_UNDECLARED] ) annotatedFormula[expr] RPAREN_TOK annotatedFormula[expr] ( termAnnotation[expr] )* RPAREN_TOK | TRUE_TOK | FALSE_TOK | NUMERAL_TOK | RATIONAL_TOK |n= BITVECTOR_BV_CONST '[' size= NUMERAL_TOK ']' |n= BITVECTOR1_BV_CONST | ( identifier[name,CHECK_DECLARED,SYM_VARIABLE] | let_identifier[name,CHECK_DECLARED] | flet_identifier[name,CHECK_DECLARED] ) )

            ANTLR3_UINT32 alt18;

            alt18=12;

            switch ( LA(1) )
            {
            case LPAREN_TOK:
            	{
            		switch ( LA(2) )
            		{
            		case ITE_TOK:
            			{
            				alt18=4;
            			}
            		    break;
            		case AND_TOK:
            		case BVADD_TOK:
            		case BVAND_TOK:
            		case BVASHR_TOK:
            		case BVCOMP_TOK:
            		case BVLSHR_TOK:
            		case BVMUL_TOK:
            		case BVNAND_TOK:
            		case BVNEG_TOK:
            		case BVNOR_TOK:
            		case BVNOT_TOK:
            		case BVOR_TOK:
            		case BVSDIV_TOK:
            		case BVSGE_TOK:
            		case BVSGT_TOK:
            		case BVSHL_TOK:
            		case BVSLE_TOK:
            		case BVSLT_TOK:
            		case BVSMOD_TOK:
            		case BVSREM_TOK:
            		case BVSUB_TOK:
            		case BVUDIV_TOK:
            		case BVUGE_TOK:
            		case BVUGT_TOK:
            		case BVULE_TOK:
            		case BVULT_TOK:
            		case BVUREM_TOK:
            		case BVXNOR_TOK:
            		case BVXOR_TOK:
            		case CONCAT_TOK:
            		case DISTINCT_TOK:
            		case DIV_TOK:
            		case EQUAL_TOK:
            		case GREATER_THAN_TOK:
            		case IFF_TOK:
            		case IMPLIES_TOK:
            		case LESS_THAN_TOK:
            		case MINUS_TOK:
            		case NOT_TOK:
            		case OR_TOK:
            		case PLUS_TOK:
            		case SELECT_TOK:
            		case STAR_TOK:
            		case STORE_TOK:
            		case TILDE_TOK:
            		case XOR_TOK:
            			{
            				alt18=1;
            			}
            		    break;
            		case EXISTS_TOK:
            		case FORALL_TOK:
            			{
            				alt18=2;
            			}
            		    break;
            		case EXTRACT_TOK:
            		case IDENTIFIER:
            		case REPEAT_TOK:
            		case ROTATE_LEFT_TOK:
            		case ROTATE_RIGHT_TOK:
            		case SIGN_EXTEND_TOK:
            		case ZERO_EXTEND_TOK:
            			{
            				alt18=3;
            			}
            		    break;
            		case FLET_TOK:
            		case LET_TOK:
            			{
            				alt18=5;
            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 18;
            		    EXCEPTION->state        = 1;


            		    goto ruleannotatedFormulaEx;

            		}

            	}
                break;
            case TRUE_TOK:
            	{
            		alt18=6;
            	}
                break;
            case FALSE_TOK:
            	{
            		alt18=7;
            	}
                break;
            case NUMERAL_TOK:
            	{
            		alt18=8;
            	}
                break;
            case RATIONAL_TOK:
            	{
            		alt18=9;
            	}
                break;
            case BITVECTOR_BV_CONST:
            	{
            		alt18=10;
            	}
                break;
            case BITVECTOR1_BV_CONST:
            	{
            		alt18=11;
            	}
                break;
            case FLET_IDENTIFIER:
            case IDENTIFIER:
            case LET_IDENTIFIER:
            	{
            		alt18=12;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 18;
                EXCEPTION->state        = 0;


                goto ruleannotatedFormulaEx;

            }

            switch (alt18)
            {
        	case 1:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:236:5: LPAREN_TOK builtinOp[kind] annotatedFormulas[args,expr] ( termAnnotation[expr] )* RPAREN_TOK
        	    {
        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_annotatedFormula481);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotatedFormulaEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_builtinOp_in_annotatedFormula483);
        	        builtinOp(ctx, kind);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotatedFormulaEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_annotatedFormulas_in_annotatedFormula486);
        	        annotatedFormulas(ctx, args, expr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotatedFormulaEx;
        	        }


        	        {
        	             if((kind == CVC4::kind::AND || kind == CVC4::kind::OR) && args.size() == 1) {
        	                    /* Unary AND/OR can be replaced with the argument.
        	            	 * It just so happens expr should already be the only argument. */
        	                    assert( expr == args[0] );
        	                  } else if( CVC4::kind::isAssociative(kind) &&
        	                             args.size() > EXPR_MANAGER->maxArity(kind) ) {
        	                	/* Special treatment for associative operators with lots of children */
        	                    expr = EXPR_MANAGER->mkAssociative(kind,args);
        	                  } else if(!PARSER_STATE->strictModeEnabled() &&
        	                            kind == CVC4::kind::MINUS && args.size() == 1) {
        	                    /* Special fix-up for unary minus improperly used in some benchmarks */
        	                    expr = MK_EXPR(CVC4::kind::UMINUS, args[0]);
        	                  } else {
        	                    PARSER_STATE->checkArity(kind, args.size());
        	                    expr = MK_EXPR(kind, args);
        	                  }
        	                
        	        }


        	        // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:254:5: ( termAnnotation[expr] )*

        	        for (;;)
        	        {
        	            int alt9=2;
        	            switch ( LA(1) )
        	            {
        	            case ATTR_IDENTIFIER:
        	            case PATTERN_ANNOTATION_BEGIN:
        	            case 101:
        	            	{
        	            		alt9=1;
        	            	}
        	                break;

        	            }

        	            switch (alt9)
        	            {
        	        	case 1:
        	        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:254:5: termAnnotation[expr]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_termAnnotation_in_annotatedFormula499);
        	        	        termAnnotation(ctx, expr);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleannotatedFormulaEx;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop9;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop9: ; /* Jump out to here if this rule does not match */


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_annotatedFormula503);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotatedFormulaEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:257:5: LPAREN_TOK ( FORALL_TOK | EXISTS_TOK ) ( LPAREN_TOK let_identifier[name,CHECK_NONE] t= sortSymbol RPAREN_TOK )+ annotatedFormula[expr] ( termAnnotation[expr] )* RPAREN_TOK
        	    {
        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_annotatedFormula516);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotatedFormulaEx;
        	        }


        	        // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:258:5: ( FORALL_TOK | EXISTS_TOK )
        	        {
        	            int alt10=2;
        	            switch ( LA(1) )
        	            {
        	            case FORALL_TOK:
        	            	{
        	            		alt10=1;
        	            	}
        	                break;
        	            case EXISTS_TOK:
        	            	{
        	            		alt10=2;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 10;
        	                EXCEPTION->state        = 0;


        	                goto ruleannotatedFormulaEx;

        	            }

        	            switch (alt10)
        	            {
        	        	case 1:
        	        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:258:7: FORALL_TOK
        	        	    {
        	        	         MATCHT(FORALL_TOK, &FOLLOW_FORALL_TOK_in_annotatedFormula524);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleannotatedFormulaEx;
        	        	        }


        	        	        {
        	        	             kind = kind::FORALL; 
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:258:45: EXISTS_TOK
        	        	    {
        	        	         MATCHT(EXISTS_TOK, &FOLLOW_EXISTS_TOK_in_annotatedFormula530);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleannotatedFormulaEx;
        	        	        }


        	        	        {
        	        	             kind = kind::EXISTS; 
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        {
        	             PARSER_STATE->pushScope(); 
        	        }


        	        // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:260:5: ( LPAREN_TOK let_identifier[name,CHECK_NONE] t= sortSymbol RPAREN_TOK )+
        	        {
        	            int cnt11=0;

        	            for (;;)
        	            {
        	                int alt11=2;
        	        	switch ( LA(1) )
        	        	{
        	        	case LPAREN_TOK:
        	        		{
        	        			switch ( LA(2) )
        	        			{
        	        			case LET_IDENTIFIER:
        	        				{
        	        					alt11=1;
        	        				}
        	        			    break;

        	        			}

        	        		}
        	        	    break;

        	        	}

        	        	switch (alt11)
        	        	{
        	        	    case 1:
        	        	        // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:260:7: LPAREN_TOK let_identifier[name,CHECK_NONE] t= sortSymbol RPAREN_TOK
        	        	        {
        	        	             MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_annotatedFormula548);
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruleannotatedFormulaEx;
        	        	            }


        	        	            FOLLOWPUSH(FOLLOW_let_identifier_in_annotatedFormula550);
        	        	            let_identifier(ctx, name, CHECK_NONE);

        	        	            FOLLOWPOP();
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruleannotatedFormulaEx;
        	        	            }


        	        	            FOLLOWPUSH(FOLLOW_sortSymbol_in_annotatedFormula555);
        	        	            t=sortSymbol(ctx);

        	        	            FOLLOWPOP();
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruleannotatedFormulaEx;
        	        	            }


        	        	             MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_annotatedFormula557);
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruleannotatedFormulaEx;
        	        	            }


        	        	            {
        	        	                 args.push_back(PARSER_STATE->mkBoundVar(name, t)); 
        	        	            }


        	        	        }
        	        	        break;

        	        	    default:

        	        		if ( cnt11 >= 1 )
        	        		{
        	        		    goto loop11;
        	        		}
        	        		/* mismatchedSetEx()
        	        		 */
        	        		CONSTRUCTEX();
        	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        	        		goto ruleannotatedFormulaEx;
        	        	}
        	        	cnt11++;
        	            }
        	            loop11: ;	/* Jump to here if this rule does not match */
        	        }

        	        FOLLOWPUSH(FOLLOW_annotatedFormula_in_annotatedFormula578);
        	        annotatedFormula(ctx, expr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotatedFormulaEx;
        	        }


        	        {
        	             args2.push_back( MK_EXPR( kind::BOUND_VAR_LIST, args ) );
        	                  args2.push_back(expr);
        	                  expr = MK_EXPR(kind, args2);
        	                
        	        }


        	        // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:268:5: ( termAnnotation[expr] )*

        	        for (;;)
        	        {
        	            int alt12=2;
        	            switch ( LA(1) )
        	            {
        	            case ATTR_IDENTIFIER:
        	            case PATTERN_ANNOTATION_BEGIN:
        	            case 101:
        	            	{
        	            		alt12=1;
        	            	}
        	                break;

        	            }

        	            switch (alt12)
        	            {
        	        	case 1:
        	        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:268:5: termAnnotation[expr]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_termAnnotation_in_annotatedFormula591);
        	        	        termAnnotation(ctx, expr);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleannotatedFormulaEx;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop12;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop12: ; /* Jump out to here if this rule does not match */


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_annotatedFormula595);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotatedFormulaEx;
        	        }


        	        {
        	             PARSER_STATE->popScope(); 
        	        }


        	    }
        	    break;
        	case 3:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:276:5: LPAREN_TOK parameterizedOperator[op] annotatedFormulas[args,expr] ( termAnnotation[expr] )* RPAREN_TOK
        	    {
        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_annotatedFormula630);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotatedFormulaEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_parameterizedOperator_in_annotatedFormula636);
        	        parameterizedOperator(ctx, op);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotatedFormulaEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_annotatedFormulas_in_annotatedFormula643);
        	        annotatedFormulas(ctx, args, expr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotatedFormulaEx;
        	        }


        	        {
        	             expr = MK_EXPR(op,args); 
        	        }


        	        // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:281:5: ( termAnnotation[expr] )*

        	        for (;;)
        	        {
        	            int alt13=2;
        	            switch ( LA(1) )
        	            {
        	            case ATTR_IDENTIFIER:
        	            case PATTERN_ANNOTATION_BEGIN:
        	            case 101:
        	            	{
        	            		alt13=1;
        	            	}
        	                break;

        	            }

        	            switch (alt13)
        	            {
        	        	case 1:
        	        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:281:5: termAnnotation[expr]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_termAnnotation_in_annotatedFormula661);
        	        	        termAnnotation(ctx, expr);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleannotatedFormulaEx;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop13;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop13: ; /* Jump out to here if this rule does not match */


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_annotatedFormula665);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotatedFormulaEx;
        	        }


        	    }
        	    break;
        	case 4:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:284:5: LPAREN_TOK ITE_TOK annotatedFormula[expr] annotatedFormula[expr] annotatedFormula[expr] ( termAnnotation[expr] )* RPAREN_TOK
        	    {
        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_annotatedFormula678);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotatedFormulaEx;
        	        }


        	         MATCHT(ITE_TOK, &FOLLOW_ITE_TOK_in_annotatedFormula680);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotatedFormulaEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_annotatedFormula_in_annotatedFormula686);
        	        annotatedFormula(ctx, expr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotatedFormulaEx;
        	        }


        	        {
        	             args.push_back(expr); 
        	        }


        	        FOLLOWPUSH(FOLLOW_annotatedFormula_in_annotatedFormula699);
        	        annotatedFormula(ctx, expr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotatedFormulaEx;
        	        }


        	        {
        	             args.push_back(expr); 
        	        }


        	        FOLLOWPUSH(FOLLOW_annotatedFormula_in_annotatedFormula712);
        	        annotatedFormula(ctx, expr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotatedFormulaEx;
        	        }


        	        {
        	             args.push_back(expr);
        	                  expr = MK_EXPR(CVC4::kind::ITE, args); 
        	        }


        	        // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:292:5: ( termAnnotation[expr] )*

        	        for (;;)
        	        {
        	            int alt14=2;
        	            switch ( LA(1) )
        	            {
        	            case ATTR_IDENTIFIER:
        	            case PATTERN_ANNOTATION_BEGIN:
        	            case 101:
        	            	{
        	            		alt14=1;
        	            	}
        	                break;

        	            }

        	            switch (alt14)
        	            {
        	        	case 1:
        	        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:292:5: termAnnotation[expr]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_termAnnotation_in_annotatedFormula725);
        	        	        termAnnotation(ctx, expr);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleannotatedFormulaEx;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop14;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop14: ; /* Jump out to here if this rule does not match */


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_annotatedFormula729);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotatedFormulaEx;
        	        }


        	    }
        	    break;
        	case 5:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:295:5: LPAREN_TOK ( LET_TOK LPAREN_TOK let_identifier[name,CHECK_UNDECLARED] | FLET_TOK LPAREN_TOK flet_identifier[name,CHECK_UNDECLARED] ) annotatedFormula[expr] RPAREN_TOK annotatedFormula[expr] ( termAnnotation[expr] )* RPAREN_TOK
        	    {
        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_annotatedFormula742);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotatedFormulaEx;
        	        }


        	        // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:296:5: ( LET_TOK LPAREN_TOK let_identifier[name,CHECK_UNDECLARED] | FLET_TOK LPAREN_TOK flet_identifier[name,CHECK_UNDECLARED] )
        	        {
        	            int alt15=2;
        	            switch ( LA(1) )
        	            {
        	            case LET_TOK:
        	            	{
        	            		alt15=1;
        	            	}
        	                break;
        	            case FLET_TOK:
        	            	{
        	            		alt15=2;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 15;
        	                EXCEPTION->state        = 0;


        	                goto ruleannotatedFormulaEx;

        	            }

        	            switch (alt15)
        	            {
        	        	case 1:
        	        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:296:7: LET_TOK LPAREN_TOK let_identifier[name,CHECK_UNDECLARED]
        	        	    {
        	        	         MATCHT(LET_TOK, &FOLLOW_LET_TOK_in_annotatedFormula750);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleannotatedFormulaEx;
        	        	        }


        	        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_annotatedFormula752);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleannotatedFormulaEx;
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_let_identifier_in_annotatedFormula754);
        	        	        let_identifier(ctx, name, CHECK_UNDECLARED);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleannotatedFormulaEx;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:297:9: FLET_TOK LPAREN_TOK flet_identifier[name,CHECK_UNDECLARED]
        	        	    {
        	        	         MATCHT(FLET_TOK, &FOLLOW_FLET_TOK_in_annotatedFormula765);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleannotatedFormulaEx;
        	        	        }


        	        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_annotatedFormula767);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleannotatedFormulaEx;
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_flet_identifier_in_annotatedFormula769);
        	        	        flet_identifier(ctx, name, CHECK_UNDECLARED);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleannotatedFormulaEx;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        FOLLOWPUSH(FOLLOW_annotatedFormula_in_annotatedFormula778);
        	        annotatedFormula(ctx, expr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotatedFormulaEx;
        	        }


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_annotatedFormula781);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotatedFormulaEx;
        	        }


        	        {
        	             PARSER_STATE->pushScope();
        	                  PARSER_STATE->defineVar(name,expr); 
        	        }


        	        FOLLOWPUSH(FOLLOW_annotatedFormula_in_annotatedFormula793);
        	        annotatedFormula(ctx, expr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotatedFormulaEx;
        	        }


        	        // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:302:5: ( termAnnotation[expr] )*

        	        for (;;)
        	        {
        	            int alt16=2;
        	            switch ( LA(1) )
        	            {
        	            case ATTR_IDENTIFIER:
        	            case PATTERN_ANNOTATION_BEGIN:
        	            case 101:
        	            	{
        	            		alt16=1;
        	            	}
        	                break;

        	            }

        	            switch (alt16)
        	            {
        	        	case 1:
        	        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:302:5: termAnnotation[expr]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_termAnnotation_in_annotatedFormula800);
        	        	        termAnnotation(ctx, expr);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleannotatedFormulaEx;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop16;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop16: ; /* Jump out to here if this rule does not match */


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_annotatedFormula804);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotatedFormulaEx;
        	        }


        	        {
        	             PARSER_STATE->popScope(); 
        	        }


        	    }
        	    break;
        	case 6:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:306:5: TRUE_TOK
        	    {
        	         MATCHT(TRUE_TOK, &FOLLOW_TRUE_TOK_in_annotatedFormula823);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotatedFormulaEx;
        	        }


        	        {
        	             expr = MK_CONST(bool(true)); 
        	        }


        	    }
        	    break;
        	case 7:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:307:5: FALSE_TOK
        	    {
        	         MATCHT(FALSE_TOK, &FOLLOW_FALSE_TOK_in_annotatedFormula840);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotatedFormulaEx;
        	        }


        	        {
        	             expr = MK_CONST(bool(false)); 
        	        }


        	    }
        	    break;
        	case 8:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:308:5: NUMERAL_TOK
        	    {
        	        NUMERAL_TOK2 = (pANTLR3_COMMON_TOKEN) MATCHT(NUMERAL_TOK, &FOLLOW_NUMERAL_TOK_in_annotatedFormula856);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotatedFormulaEx;
        	        }


        	        {
        	             expr = MK_CONST( AntlrInput::tokenToInteger(NUMERAL_TOK2) ); 
        	        }


        	    }
        	    break;
        	case 9:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:310:5: RATIONAL_TOK
        	    {
        	        RATIONAL_TOK3 = (pANTLR3_COMMON_TOKEN) MATCHT(RATIONAL_TOK, &FOLLOW_RATIONAL_TOK_in_annotatedFormula868);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotatedFormulaEx;
        	        }


        	        {
        	             // FIXME: This doesn't work because an SMT rational is not a
        	                  // valid GMP rational string
        	                  expr = MK_CONST( AntlrInput::tokenToRational(RATIONAL_TOK3) ); 
        	        }


        	    }
        	    break;
        	case 10:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:314:5: n= BITVECTOR_BV_CONST '[' size= NUMERAL_TOK ']'
        	    {
        	        n = (pANTLR3_COMMON_TOKEN) MATCHT(BITVECTOR_BV_CONST, &FOLLOW_BITVECTOR_BV_CONST_in_annotatedFormula884);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotatedFormulaEx;
        	        }


        	         MATCHT(103, &FOLLOW_103_in_annotatedFormula886);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotatedFormulaEx;
        	        }


        	        size = (pANTLR3_COMMON_TOKEN) MATCHT(NUMERAL_TOK, &FOLLOW_NUMERAL_TOK_in_annotatedFormula892);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotatedFormulaEx;
        	        }


        	         MATCHT(104, &FOLLOW_104_in_annotatedFormula894);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotatedFormulaEx;
        	        }


        	        {
        	             expr = MK_CONST( AntlrInput::tokenToBitvector(n, size) ); 
        	        }


        	    }
        	    break;
        	case 11:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:316:5: n= BITVECTOR1_BV_CONST
        	    {
        	        n = (pANTLR3_COMMON_TOKEN) MATCHT(BITVECTOR1_BV_CONST, &FOLLOW_BITVECTOR1_BV_CONST_in_annotatedFormula910);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotatedFormulaEx;
        	        }


        	        {
        	             unsigned int bit = AntlrInput::tokenText(n)[3] - '0';
        	                  expr = MK_CONST( BitVector(1, bit) );
        	                
        	        }


        	    }
        	    break;
        	case 12:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:324:5: ( identifier[name,CHECK_DECLARED,SYM_VARIABLE] | let_identifier[name,CHECK_DECLARED] | flet_identifier[name,CHECK_DECLARED] )
        	    {
        	        // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:324:5: ( identifier[name,CHECK_DECLARED,SYM_VARIABLE] | let_identifier[name,CHECK_DECLARED] | flet_identifier[name,CHECK_DECLARED] )
        	        {
        	            int alt17=3;
        	            switch ( LA(1) )
        	            {
        	            case IDENTIFIER:
        	            	{
        	            		alt17=1;
        	            	}
        	                break;
        	            case LET_IDENTIFIER:
        	            	{
        	            		alt17=2;
        	            	}
        	                break;
        	            case FLET_IDENTIFIER:
        	            	{
        	            		alt17=3;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 17;
        	                EXCEPTION->state        = 0;


        	                goto ruleannotatedFormulaEx;

        	            }

        	            switch (alt17)
        	            {
        	        	case 1:
        	        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:324:7: identifier[name,CHECK_DECLARED,SYM_VARIABLE]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_identifier_in_annotatedFormula942);
        	        	        identifier(ctx, name, CHECK_DECLARED, SYM_VARIABLE);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleannotatedFormulaEx;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:325:9: let_identifier[name,CHECK_DECLARED]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_let_identifier_in_annotatedFormula953);
        	        	        let_identifier(ctx, name, CHECK_DECLARED);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleannotatedFormulaEx;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 3:
        	        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:326:9: flet_identifier[name,CHECK_DECLARED]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_flet_identifier_in_annotatedFormula964);
        	        	        flet_identifier(ctx, name, CHECK_DECLARED);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleannotatedFormulaEx;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        {
        	             expr = PARSER_STATE->getVariable(name); 
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleannotatedFormulaEx; /* Prevent compiler warnings */
    ruleannotatedFormulaEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end annotatedFormula */

/**
 * $ANTLR start annotatedFormulas
 * /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:338:1: annotatedFormulas[std::vector<CVC4::Expr>& formulas, CVC4::Expr& expr] : ( annotatedFormula[expr] )+ ;
 */
static void
annotatedFormulas(pSmt1Parser ctx, std::vector<CVC4::Expr>& formulas, CVC4::Expr& expr)
{
    /* Initialize rule variables
     */

    {
        // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:339:3: ( ( annotatedFormula[expr] )+ )
        // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:339:5: ( annotatedFormula[expr] )+
        {
            // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:339:5: ( annotatedFormula[expr] )+
            {
                int cnt19=0;

                for (;;)
                {
                    int alt19=2;
            	switch ( LA(1) )
            	{
            	case BITVECTOR1_BV_CONST:
            	case BITVECTOR_BV_CONST:
            	case FALSE_TOK:
            	case FLET_IDENTIFIER:
            	case IDENTIFIER:
            	case LET_IDENTIFIER:
            	case LPAREN_TOK:
            	case NUMERAL_TOK:
            	case RATIONAL_TOK:
            	case TRUE_TOK:
            		{
            			alt19=1;
            		}
            	    break;

            	}

            	switch (alt19)
            	{
            	    case 1:
            	        // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:339:7: annotatedFormula[expr]
            	        {
            	            FOLLOWPUSH(FOLLOW_annotatedFormula_in_annotatedFormulas993);
            	            annotatedFormula(ctx, expr);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleannotatedFormulasEx;
            	            }


            	            {
            	                 formulas.push_back(expr); 
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt19 >= 1 )
            		{
            		    goto loop19;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto ruleannotatedFormulasEx;
            	}
            	cnt19++;
                }
                loop19: ;	/* Jump to here if this rule does not match */
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleannotatedFormulasEx; /* Prevent compiler warnings */
    ruleannotatedFormulasEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end annotatedFormulas */

/**
 * $ANTLR start builtinOp
 * /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:345:1: builtinOp[CVC4::Kind& kind] : ( NOT_TOK | IMPLIES_TOK | AND_TOK | OR_TOK | XOR_TOK | IFF_TOK | EQUAL_TOK | DISTINCT_TOK | GREATER_THAN_TOK | GREATER_THAN_TOK EQUAL_TOK | LESS_THAN_TOK EQUAL_TOK | LESS_THAN_TOK | PLUS_TOK | STAR_TOK | TILDE_TOK | MINUS_TOK | DIV_TOK | CONCAT_TOK | BVAND_TOK | BVOR_TOK | BVXOR_TOK | BVNOT_TOK | BVNAND_TOK | BVNOR_TOK | BVXNOR_TOK | BVCOMP_TOK | BVMUL_TOK | BVADD_TOK | BVSUB_TOK | BVNEG_TOK | BVUDIV_TOK | BVUREM_TOK | BVSDIV_TOK | BVSREM_TOK | BVSMOD_TOK | BVSHL_TOK | BVLSHR_TOK | BVASHR_TOK | BVULT_TOK | BVULE_TOK | BVUGT_TOK | BVUGE_TOK | BVSLT_TOK | BVSLE_TOK | BVSGT_TOK | BVSGE_TOK | SELECT_TOK | STORE_TOK );
 */
static void
builtinOp(pSmt1Parser ctx, CVC4::Kind& kind)
{
    /* Initialize rule variables
     */


      Debug("parser") << "builtin: " << AntlrInput::tokenText(LT(1)) << std::endl;

    {
        {
            //  /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:349:3: ( NOT_TOK | IMPLIES_TOK | AND_TOK | OR_TOK | XOR_TOK | IFF_TOK | EQUAL_TOK | DISTINCT_TOK | GREATER_THAN_TOK | GREATER_THAN_TOK EQUAL_TOK | LESS_THAN_TOK EQUAL_TOK | LESS_THAN_TOK | PLUS_TOK | STAR_TOK | TILDE_TOK | MINUS_TOK | DIV_TOK | CONCAT_TOK | BVAND_TOK | BVOR_TOK | BVXOR_TOK | BVNOT_TOK | BVNAND_TOK | BVNOR_TOK | BVXNOR_TOK | BVCOMP_TOK | BVMUL_TOK | BVADD_TOK | BVSUB_TOK | BVNEG_TOK | BVUDIV_TOK | BVUREM_TOK | BVSDIV_TOK | BVSREM_TOK | BVSMOD_TOK | BVSHL_TOK | BVLSHR_TOK | BVASHR_TOK | BVULT_TOK | BVULE_TOK | BVUGT_TOK | BVUGE_TOK | BVSLT_TOK | BVSLE_TOK | BVSGT_TOK | BVSGE_TOK | SELECT_TOK | STORE_TOK )

            ANTLR3_UINT32 alt20;

            alt20=48;

            switch ( LA(1) )
            {
            case NOT_TOK:
            	{
            		alt20=1;
            	}
                break;
            case IMPLIES_TOK:
            	{
            		alt20=2;
            	}
                break;
            case AND_TOK:
            	{
            		alt20=3;
            	}
                break;
            case OR_TOK:
            	{
            		alt20=4;
            	}
                break;
            case XOR_TOK:
            	{
            		alt20=5;
            	}
                break;
            case IFF_TOK:
            	{
            		alt20=6;
            	}
                break;
            case EQUAL_TOK:
            	{
            		alt20=7;
            	}
                break;
            case DISTINCT_TOK:
            	{
            		alt20=8;
            	}
                break;
            case GREATER_THAN_TOK:
            	{
            		switch ( LA(2) )
            		{
            		case EQUAL_TOK:
            			{
            				alt20=10;
            			}
            		    break;
            		case BITVECTOR1_BV_CONST:
            		case BITVECTOR_BV_CONST:
            		case FALSE_TOK:
            		case FLET_IDENTIFIER:
            		case IDENTIFIER:
            		case LET_IDENTIFIER:
            		case LPAREN_TOK:
            		case NUMERAL_TOK:
            		case RATIONAL_TOK:
            		case TRUE_TOK:
            			{
            				alt20=9;
            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 20;
            		    EXCEPTION->state        = 9;


            		    goto rulebuiltinOpEx;

            		}

            	}
                break;
            case LESS_THAN_TOK:
            	{
            		switch ( LA(2) )
            		{
            		case EQUAL_TOK:
            			{
            				alt20=11;
            			}
            		    break;
            		case BITVECTOR1_BV_CONST:
            		case BITVECTOR_BV_CONST:
            		case FALSE_TOK:
            		case FLET_IDENTIFIER:
            		case IDENTIFIER:
            		case LET_IDENTIFIER:
            		case LPAREN_TOK:
            		case NUMERAL_TOK:
            		case RATIONAL_TOK:
            		case TRUE_TOK:
            			{
            				alt20=12;
            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 20;
            		    EXCEPTION->state        = 10;


            		    goto rulebuiltinOpEx;

            		}

            	}
                break;
            case PLUS_TOK:
            	{
            		alt20=13;
            	}
                break;
            case STAR_TOK:
            	{
            		alt20=14;
            	}
                break;
            case TILDE_TOK:
            	{
            		alt20=15;
            	}
                break;
            case MINUS_TOK:
            	{
            		alt20=16;
            	}
                break;
            case DIV_TOK:
            	{
            		alt20=17;
            	}
                break;
            case CONCAT_TOK:
            	{
            		alt20=18;
            	}
                break;
            case BVAND_TOK:
            	{
            		alt20=19;
            	}
                break;
            case BVOR_TOK:
            	{
            		alt20=20;
            	}
                break;
            case BVXOR_TOK:
            	{
            		alt20=21;
            	}
                break;
            case BVNOT_TOK:
            	{
            		alt20=22;
            	}
                break;
            case BVNAND_TOK:
            	{
            		alt20=23;
            	}
                break;
            case BVNOR_TOK:
            	{
            		alt20=24;
            	}
                break;
            case BVXNOR_TOK:
            	{
            		alt20=25;
            	}
                break;
            case BVCOMP_TOK:
            	{
            		alt20=26;
            	}
                break;
            case BVMUL_TOK:
            	{
            		alt20=27;
            	}
                break;
            case BVADD_TOK:
            	{
            		alt20=28;
            	}
                break;
            case BVSUB_TOK:
            	{
            		alt20=29;
            	}
                break;
            case BVNEG_TOK:
            	{
            		alt20=30;
            	}
                break;
            case BVUDIV_TOK:
            	{
            		alt20=31;
            	}
                break;
            case BVUREM_TOK:
            	{
            		alt20=32;
            	}
                break;
            case BVSDIV_TOK:
            	{
            		alt20=33;
            	}
                break;
            case BVSREM_TOK:
            	{
            		alt20=34;
            	}
                break;
            case BVSMOD_TOK:
            	{
            		alt20=35;
            	}
                break;
            case BVSHL_TOK:
            	{
            		alt20=36;
            	}
                break;
            case BVLSHR_TOK:
            	{
            		alt20=37;
            	}
                break;
            case BVASHR_TOK:
            	{
            		alt20=38;
            	}
                break;
            case BVULT_TOK:
            	{
            		alt20=39;
            	}
                break;
            case BVULE_TOK:
            	{
            		alt20=40;
            	}
                break;
            case BVUGT_TOK:
            	{
            		alt20=41;
            	}
                break;
            case BVUGE_TOK:
            	{
            		alt20=42;
            	}
                break;
            case BVSLT_TOK:
            	{
            		alt20=43;
            	}
                break;
            case BVSLE_TOK:
            	{
            		alt20=44;
            	}
                break;
            case BVSGT_TOK:
            	{
            		alt20=45;
            	}
                break;
            case BVSGE_TOK:
            	{
            		alt20=46;
            	}
                break;
            case SELECT_TOK:
            	{
            		alt20=47;
            	}
                break;
            case STORE_TOK:
            	{
            		alt20=48;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 20;
                EXCEPTION->state        = 0;


                goto rulebuiltinOpEx;

            }

            switch (alt20)
            {
        	case 1:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:349:5: NOT_TOK
        	    {
        	         MATCHT(NOT_TOK, &FOLLOW_NOT_TOK_in_builtinOp1020);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::NOT;     
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:350:5: IMPLIES_TOK
        	    {
        	         MATCHT(IMPLIES_TOK, &FOLLOW_IMPLIES_TOK_in_builtinOp1033);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::IMPLIES; 
        	        }


        	    }
        	    break;
        	case 3:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:351:5: AND_TOK
        	    {
        	         MATCHT(AND_TOK, &FOLLOW_AND_TOK_in_builtinOp1042);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::AND;     
        	        }


        	    }
        	    break;
        	case 4:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:352:5: OR_TOK
        	    {
        	         MATCHT(OR_TOK, &FOLLOW_OR_TOK_in_builtinOp1055);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::OR;      
        	        }


        	    }
        	    break;
        	case 5:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:353:5: XOR_TOK
        	    {
        	         MATCHT(XOR_TOK, &FOLLOW_XOR_TOK_in_builtinOp1069);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::XOR;     
        	        }


        	    }
        	    break;
        	case 6:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:354:5: IFF_TOK
        	    {
        	         MATCHT(IFF_TOK, &FOLLOW_IFF_TOK_in_builtinOp1082);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::IFF;     
        	        }


        	    }
        	    break;
        	case 7:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:355:5: EQUAL_TOK
        	    {
        	         MATCHT(EQUAL_TOK, &FOLLOW_EQUAL_TOK_in_builtinOp1095);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::EQUAL;   
        	        }


        	    }
        	    break;
        	case 8:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:356:5: DISTINCT_TOK
        	    {
        	         MATCHT(DISTINCT_TOK, &FOLLOW_DISTINCT_TOK_in_builtinOp1106);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::DISTINCT; 
        	        }


        	    }
        	    break;
        	case 9:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:358:5: GREATER_THAN_TOK
        	    {
        	         MATCHT(GREATER_THAN_TOK, &FOLLOW_GREATER_THAN_TOK_in_builtinOp1117);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::GT; 
        	        }


        	    }
        	    break;
        	case 10:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:360:5: GREATER_THAN_TOK EQUAL_TOK
        	    {
        	         MATCHT(GREATER_THAN_TOK, &FOLLOW_GREATER_THAN_TOK_in_builtinOp1142);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	         MATCHT(EQUAL_TOK, &FOLLOW_EQUAL_TOK_in_builtinOp1144);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::GEQ; 
        	        }


        	    }
        	    break;
        	case 11:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:362:5: LESS_THAN_TOK EQUAL_TOK
        	    {
        	         MATCHT(LESS_THAN_TOK, &FOLLOW_LESS_THAN_TOK_in_builtinOp1169);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	         MATCHT(EQUAL_TOK, &FOLLOW_EQUAL_TOK_in_builtinOp1171);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::LEQ; 
        	        }


        	    }
        	    break;
        	case 12:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:364:5: LESS_THAN_TOK
        	    {
        	         MATCHT(LESS_THAN_TOK, &FOLLOW_LESS_THAN_TOK_in_builtinOp1196);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::LT; 
        	        }


        	    }
        	    break;
        	case 13:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:366:5: PLUS_TOK
        	    {
        	         MATCHT(PLUS_TOK, &FOLLOW_PLUS_TOK_in_builtinOp1221);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::PLUS; 
        	        }


        	    }
        	    break;
        	case 14:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:367:5: STAR_TOK
        	    {
        	         MATCHT(STAR_TOK, &FOLLOW_STAR_TOK_in_builtinOp1233);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::MULT; 
        	        }


        	    }
        	    break;
        	case 15:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:368:5: TILDE_TOK
        	    {
        	         MATCHT(TILDE_TOK, &FOLLOW_TILDE_TOK_in_builtinOp1245);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::UMINUS; 
        	        }


        	    }
        	    break;
        	case 16:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:369:5: MINUS_TOK
        	    {
        	         MATCHT(MINUS_TOK, &FOLLOW_MINUS_TOK_in_builtinOp1256);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::MINUS; 
        	        }


        	    }
        	    break;
        	case 17:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:370:5: DIV_TOK
        	    {
        	         MATCHT(DIV_TOK, &FOLLOW_DIV_TOK_in_builtinOp1267);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::DIVISION; 
        	        }


        	    }
        	    break;
        	case 18:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:372:5: CONCAT_TOK
        	    {
        	         MATCHT(CONCAT_TOK, &FOLLOW_CONCAT_TOK_in_builtinOp1283);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::BITVECTOR_CONCAT; 
        	        }


        	    }
        	    break;
        	case 19:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:373:5: BVAND_TOK
        	    {
        	         MATCHT(BVAND_TOK, &FOLLOW_BVAND_TOK_in_builtinOp1293);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::BITVECTOR_AND;    
        	        }


        	    }
        	    break;
        	case 20:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:374:5: BVOR_TOK
        	    {
        	         MATCHT(BVOR_TOK, &FOLLOW_BVOR_TOK_in_builtinOp1304);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::BITVECTOR_OR;     
        	        }


        	    }
        	    break;
        	case 21:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:375:5: BVXOR_TOK
        	    {
        	         MATCHT(BVXOR_TOK, &FOLLOW_BVXOR_TOK_in_builtinOp1316);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::BITVECTOR_XOR;    
        	        }


        	    }
        	    break;
        	case 22:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:376:5: BVNOT_TOK
        	    {
        	         MATCHT(BVNOT_TOK, &FOLLOW_BVNOT_TOK_in_builtinOp1327);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::BITVECTOR_NOT;    
        	        }


        	    }
        	    break;
        	case 23:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:377:5: BVNAND_TOK
        	    {
        	         MATCHT(BVNAND_TOK, &FOLLOW_BVNAND_TOK_in_builtinOp1338);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::BITVECTOR_NAND;   
        	        }


        	    }
        	    break;
        	case 24:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:378:5: BVNOR_TOK
        	    {
        	         MATCHT(BVNOR_TOK, &FOLLOW_BVNOR_TOK_in_builtinOp1348);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::BITVECTOR_NOR;    
        	        }


        	    }
        	    break;
        	case 25:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:379:5: BVXNOR_TOK
        	    {
        	         MATCHT(BVXNOR_TOK, &FOLLOW_BVXNOR_TOK_in_builtinOp1359);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::BITVECTOR_XNOR;   
        	        }


        	    }
        	    break;
        	case 26:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:380:5: BVCOMP_TOK
        	    {
        	         MATCHT(BVCOMP_TOK, &FOLLOW_BVCOMP_TOK_in_builtinOp1369);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::BITVECTOR_COMP;   
        	        }


        	    }
        	    break;
        	case 27:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:381:5: BVMUL_TOK
        	    {
        	         MATCHT(BVMUL_TOK, &FOLLOW_BVMUL_TOK_in_builtinOp1379);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::BITVECTOR_MULT;   
        	        }


        	    }
        	    break;
        	case 28:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:382:5: BVADD_TOK
        	    {
        	         MATCHT(BVADD_TOK, &FOLLOW_BVADD_TOK_in_builtinOp1390);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::BITVECTOR_PLUS;   
        	        }


        	    }
        	    break;
        	case 29:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:383:5: BVSUB_TOK
        	    {
        	         MATCHT(BVSUB_TOK, &FOLLOW_BVSUB_TOK_in_builtinOp1401);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::BITVECTOR_SUB;    
        	        }


        	    }
        	    break;
        	case 30:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:384:5: BVNEG_TOK
        	    {
        	         MATCHT(BVNEG_TOK, &FOLLOW_BVNEG_TOK_in_builtinOp1412);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::BITVECTOR_NEG;    
        	        }


        	    }
        	    break;
        	case 31:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:385:5: BVUDIV_TOK
        	    {
        	         MATCHT(BVUDIV_TOK, &FOLLOW_BVUDIV_TOK_in_builtinOp1423);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::BITVECTOR_UDIV;   
        	        }


        	    }
        	    break;
        	case 32:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:386:5: BVUREM_TOK
        	    {
        	         MATCHT(BVUREM_TOK, &FOLLOW_BVUREM_TOK_in_builtinOp1433);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::BITVECTOR_UREM;   
        	        }


        	    }
        	    break;
        	case 33:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:387:5: BVSDIV_TOK
        	    {
        	         MATCHT(BVSDIV_TOK, &FOLLOW_BVSDIV_TOK_in_builtinOp1443);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::BITVECTOR_SDIV;   
        	        }


        	    }
        	    break;
        	case 34:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:388:5: BVSREM_TOK
        	    {
        	         MATCHT(BVSREM_TOK, &FOLLOW_BVSREM_TOK_in_builtinOp1453);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::BITVECTOR_SREM;   
        	        }


        	    }
        	    break;
        	case 35:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:389:5: BVSMOD_TOK
        	    {
        	         MATCHT(BVSMOD_TOK, &FOLLOW_BVSMOD_TOK_in_builtinOp1463);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::BITVECTOR_SMOD;   
        	        }


        	    }
        	    break;
        	case 36:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:390:5: BVSHL_TOK
        	    {
        	         MATCHT(BVSHL_TOK, &FOLLOW_BVSHL_TOK_in_builtinOp1473);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::BITVECTOR_SHL;    
        	        }


        	    }
        	    break;
        	case 37:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:391:5: BVLSHR_TOK
        	    {
        	         MATCHT(BVLSHR_TOK, &FOLLOW_BVLSHR_TOK_in_builtinOp1484);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::BITVECTOR_LSHR;   
        	        }


        	    }
        	    break;
        	case 38:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:392:5: BVASHR_TOK
        	    {
        	         MATCHT(BVASHR_TOK, &FOLLOW_BVASHR_TOK_in_builtinOp1494);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::BITVECTOR_ASHR;   
        	        }


        	    }
        	    break;
        	case 39:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:393:5: BVULT_TOK
        	    {
        	         MATCHT(BVULT_TOK, &FOLLOW_BVULT_TOK_in_builtinOp1504);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::BITVECTOR_ULT;    
        	        }


        	    }
        	    break;
        	case 40:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:394:5: BVULE_TOK
        	    {
        	         MATCHT(BVULE_TOK, &FOLLOW_BVULE_TOK_in_builtinOp1515);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::BITVECTOR_ULE;    
        	        }


        	    }
        	    break;
        	case 41:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:395:5: BVUGT_TOK
        	    {
        	         MATCHT(BVUGT_TOK, &FOLLOW_BVUGT_TOK_in_builtinOp1526);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::BITVECTOR_UGT;    
        	        }


        	    }
        	    break;
        	case 42:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:396:5: BVUGE_TOK
        	    {
        	         MATCHT(BVUGE_TOK, &FOLLOW_BVUGE_TOK_in_builtinOp1537);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::BITVECTOR_UGE;    
        	        }


        	    }
        	    break;
        	case 43:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:397:5: BVSLT_TOK
        	    {
        	         MATCHT(BVSLT_TOK, &FOLLOW_BVSLT_TOK_in_builtinOp1548);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::BITVECTOR_SLT;    
        	        }


        	    }
        	    break;
        	case 44:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:398:5: BVSLE_TOK
        	    {
        	         MATCHT(BVSLE_TOK, &FOLLOW_BVSLE_TOK_in_builtinOp1559);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::BITVECTOR_SLE;    
        	        }


        	    }
        	    break;
        	case 45:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:399:5: BVSGT_TOK
        	    {
        	         MATCHT(BVSGT_TOK, &FOLLOW_BVSGT_TOK_in_builtinOp1570);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::BITVECTOR_SGT;    
        	        }


        	    }
        	    break;
        	case 46:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:400:5: BVSGE_TOK
        	    {
        	         MATCHT(BVSGE_TOK, &FOLLOW_BVSGE_TOK_in_builtinOp1581);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::BITVECTOR_SGE;    
        	        }


        	    }
        	    break;
        	case 47:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:402:5: SELECT_TOK
        	    {
        	         MATCHT(SELECT_TOK, &FOLLOW_SELECT_TOK_in_builtinOp1595);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::SELECT; 
        	        }


        	    }
        	    break;
        	case 48:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:403:5: STORE_TOK
        	    {
        	         MATCHT(STORE_TOK, &FOLLOW_STORE_TOK_in_builtinOp1605);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::STORE; 
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulebuiltinOpEx; /* Prevent compiler warnings */
    rulebuiltinOpEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end builtinOp */

/**
 * $ANTLR start parameterizedOperator
 * /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:410:1: parameterizedOperator[CVC4::Expr& op] : ( functionSymbol[op] | bitVectorOperator[op] );
 */
static void
parameterizedOperator(pSmt1Parser ctx, CVC4::Expr& op)
{
    /* Initialize rule variables
     */

    {
        {
            //  /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:411:3: ( functionSymbol[op] | bitVectorOperator[op] )

            ANTLR3_UINT32 alt21;

            alt21=2;

            switch ( LA(1) )
            {
            case IDENTIFIER:
            	{
            		alt21=1;
            	}
                break;
            case EXTRACT_TOK:
            case REPEAT_TOK:
            case ROTATE_LEFT_TOK:
            case ROTATE_RIGHT_TOK:
            case SIGN_EXTEND_TOK:
            case ZERO_EXTEND_TOK:
            	{
            		alt21=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 21;
                EXCEPTION->state        = 0;


                goto ruleparameterizedOperatorEx;

            }

            switch (alt21)
            {
        	case 1:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:411:5: functionSymbol[op]
        	    {
        	        FOLLOWPUSH(FOLLOW_functionSymbol_in_parameterizedOperator1629);
        	        functionSymbol(ctx, op);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparameterizedOperatorEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:412:5: bitVectorOperator[op]
        	    {
        	        FOLLOWPUSH(FOLLOW_bitVectorOperator_in_parameterizedOperator1636);
        	        bitVectorOperator(ctx, op);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparameterizedOperatorEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleparameterizedOperatorEx; /* Prevent compiler warnings */
    ruleparameterizedOperatorEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end parameterizedOperator */

/**
 * $ANTLR start bitVectorOperator
 * /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:418:1: bitVectorOperator[CVC4::Expr& op] : ( EXTRACT_TOK '[' n1= NUMERAL_TOK ':' n2= NUMERAL_TOK ']' | REPEAT_TOK '[' n= NUMERAL_TOK ']' | ZERO_EXTEND_TOK '[' n= NUMERAL_TOK ']' | SIGN_EXTEND_TOK '[' n= NUMERAL_TOK ']' | ROTATE_LEFT_TOK '[' n= NUMERAL_TOK ']' | ROTATE_RIGHT_TOK '[' n= NUMERAL_TOK ']' );
 */
static void
bitVectorOperator(pSmt1Parser ctx, CVC4::Expr& op)
{
    pANTLR3_COMMON_TOKEN    n1;
    pANTLR3_COMMON_TOKEN    n2;
    pANTLR3_COMMON_TOKEN    n;

    /* Initialize rule variables
     */

    n1       = NULL;
    n2       = NULL;
    n       = NULL;

    {
        {
            //  /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:419:3: ( EXTRACT_TOK '[' n1= NUMERAL_TOK ':' n2= NUMERAL_TOK ']' | REPEAT_TOK '[' n= NUMERAL_TOK ']' | ZERO_EXTEND_TOK '[' n= NUMERAL_TOK ']' | SIGN_EXTEND_TOK '[' n= NUMERAL_TOK ']' | ROTATE_LEFT_TOK '[' n= NUMERAL_TOK ']' | ROTATE_RIGHT_TOK '[' n= NUMERAL_TOK ']' )

            ANTLR3_UINT32 alt22;

            alt22=6;

            switch ( LA(1) )
            {
            case EXTRACT_TOK:
            	{
            		alt22=1;
            	}
                break;
            case REPEAT_TOK:
            	{
            		alt22=2;
            	}
                break;
            case ZERO_EXTEND_TOK:
            	{
            		alt22=3;
            	}
                break;
            case SIGN_EXTEND_TOK:
            	{
            		alt22=4;
            	}
                break;
            case ROTATE_LEFT_TOK:
            	{
            		alt22=5;
            	}
                break;
            case ROTATE_RIGHT_TOK:
            	{
            		alt22=6;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 22;
                EXCEPTION->state        = 0;


                goto rulebitVectorOperatorEx;

            }

            switch (alt22)
            {
        	case 1:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:419:5: EXTRACT_TOK '[' n1= NUMERAL_TOK ':' n2= NUMERAL_TOK ']'
        	    {
        	         MATCHT(EXTRACT_TOK, &FOLLOW_EXTRACT_TOK_in_bitVectorOperator1653);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebitVectorOperatorEx;
        	        }


        	         MATCHT(103, &FOLLOW_103_in_bitVectorOperator1655);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebitVectorOperatorEx;
        	        }


        	        n1 = (pANTLR3_COMMON_TOKEN) MATCHT(NUMERAL_TOK, &FOLLOW_NUMERAL_TOK_in_bitVectorOperator1661);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebitVectorOperatorEx;
        	        }


        	         MATCHT(100, &FOLLOW_100_in_bitVectorOperator1663);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebitVectorOperatorEx;
        	        }


        	        n2 = (pANTLR3_COMMON_TOKEN) MATCHT(NUMERAL_TOK, &FOLLOW_NUMERAL_TOK_in_bitVectorOperator1669);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebitVectorOperatorEx;
        	        }


        	         MATCHT(104, &FOLLOW_104_in_bitVectorOperator1671);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebitVectorOperatorEx;
        	        }


        	        {
        	             op = MK_CONST(BitVectorExtract(AntlrInput::tokenToUnsigned(n1), AntlrInput::tokenToUnsigned(n2))); 
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:421:5: REPEAT_TOK '[' n= NUMERAL_TOK ']'
        	    {
        	         MATCHT(REPEAT_TOK, &FOLLOW_REPEAT_TOK_in_bitVectorOperator1683);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebitVectorOperatorEx;
        	        }


        	         MATCHT(103, &FOLLOW_103_in_bitVectorOperator1685);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebitVectorOperatorEx;
        	        }


        	        n = (pANTLR3_COMMON_TOKEN) MATCHT(NUMERAL_TOK, &FOLLOW_NUMERAL_TOK_in_bitVectorOperator1691);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebitVectorOperatorEx;
        	        }


        	         MATCHT(104, &FOLLOW_104_in_bitVectorOperator1693);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebitVectorOperatorEx;
        	        }


        	        {
        	             op = MK_CONST(BitVectorRepeat(AntlrInput::tokenToUnsigned(n))); 
        	        }


        	    }
        	    break;
        	case 3:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:423:5: ZERO_EXTEND_TOK '[' n= NUMERAL_TOK ']'
        	    {
        	         MATCHT(ZERO_EXTEND_TOK, &FOLLOW_ZERO_EXTEND_TOK_in_bitVectorOperator1705);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebitVectorOperatorEx;
        	        }


        	         MATCHT(103, &FOLLOW_103_in_bitVectorOperator1707);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebitVectorOperatorEx;
        	        }


        	        n = (pANTLR3_COMMON_TOKEN) MATCHT(NUMERAL_TOK, &FOLLOW_NUMERAL_TOK_in_bitVectorOperator1713);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebitVectorOperatorEx;
        	        }


        	         MATCHT(104, &FOLLOW_104_in_bitVectorOperator1715);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebitVectorOperatorEx;
        	        }


        	        {
        	             op = MK_CONST(BitVectorZeroExtend(AntlrInput::tokenToUnsigned(n))); 
        	        }


        	    }
        	    break;
        	case 4:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:425:5: SIGN_EXTEND_TOK '[' n= NUMERAL_TOK ']'
        	    {
        	         MATCHT(SIGN_EXTEND_TOK, &FOLLOW_SIGN_EXTEND_TOK_in_bitVectorOperator1727);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebitVectorOperatorEx;
        	        }


        	         MATCHT(103, &FOLLOW_103_in_bitVectorOperator1729);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebitVectorOperatorEx;
        	        }


        	        n = (pANTLR3_COMMON_TOKEN) MATCHT(NUMERAL_TOK, &FOLLOW_NUMERAL_TOK_in_bitVectorOperator1735);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebitVectorOperatorEx;
        	        }


        	         MATCHT(104, &FOLLOW_104_in_bitVectorOperator1737);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebitVectorOperatorEx;
        	        }


        	        {
        	             op = MK_CONST(BitVectorSignExtend(AntlrInput::tokenToUnsigned(n))); 
        	        }


        	    }
        	    break;
        	case 5:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:427:5: ROTATE_LEFT_TOK '[' n= NUMERAL_TOK ']'
        	    {
        	         MATCHT(ROTATE_LEFT_TOK, &FOLLOW_ROTATE_LEFT_TOK_in_bitVectorOperator1749);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebitVectorOperatorEx;
        	        }


        	         MATCHT(103, &FOLLOW_103_in_bitVectorOperator1751);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebitVectorOperatorEx;
        	        }


        	        n = (pANTLR3_COMMON_TOKEN) MATCHT(NUMERAL_TOK, &FOLLOW_NUMERAL_TOK_in_bitVectorOperator1757);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebitVectorOperatorEx;
        	        }


        	         MATCHT(104, &FOLLOW_104_in_bitVectorOperator1759);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebitVectorOperatorEx;
        	        }


        	        {
        	             op = MK_CONST(BitVectorRotateLeft(AntlrInput::tokenToUnsigned(n))); 
        	        }


        	    }
        	    break;
        	case 6:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:429:5: ROTATE_RIGHT_TOK '[' n= NUMERAL_TOK ']'
        	    {
        	         MATCHT(ROTATE_RIGHT_TOK, &FOLLOW_ROTATE_RIGHT_TOK_in_bitVectorOperator1771);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebitVectorOperatorEx;
        	        }


        	         MATCHT(103, &FOLLOW_103_in_bitVectorOperator1773);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebitVectorOperatorEx;
        	        }


        	        n = (pANTLR3_COMMON_TOKEN) MATCHT(NUMERAL_TOK, &FOLLOW_NUMERAL_TOK_in_bitVectorOperator1779);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebitVectorOperatorEx;
        	        }


        	         MATCHT(104, &FOLLOW_104_in_bitVectorOperator1781);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebitVectorOperatorEx;
        	        }


        	        {
        	             op = MK_CONST(BitVectorRotateRight(AntlrInput::tokenToUnsigned(n))); 
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulebitVectorOperatorEx; /* Prevent compiler warnings */
    rulebitVectorOperatorEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end bitVectorOperator */

/**
 * $ANTLR start predicateName
 * /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:437:1: predicateName[std::string& name, CVC4::parser::DeclarationCheck check] : functionName[name,check] ;
 */
static void
predicateName(pSmt1Parser ctx, std::string& name, CVC4::parser::DeclarationCheck check)
{
    /* Initialize rule variables
     */

    {
        // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:438:3: ( functionName[name,check] )
        // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:438:6: functionName[name,check]
        {
            FOLLOWPUSH(FOLLOW_functionName_in_predicateName1804);
            functionName(ctx, name, check);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulepredicateNameEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulepredicateNameEx; /* Prevent compiler warnings */
    rulepredicateNameEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end predicateName */

/**
 * $ANTLR start functionName
 * /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:445:1: functionName[std::string& name, CVC4::parser::DeclarationCheck check] : identifier[name,check,SYM_VARIABLE] ;
 */
static void
functionName(pSmt1Parser ctx, std::string& name, CVC4::parser::DeclarationCheck check)
{
    /* Initialize rule variables
     */

    {
        // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:446:3: ( identifier[name,check,SYM_VARIABLE] )
        // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:446:6: identifier[name,check,SYM_VARIABLE]
        {
            FOLLOWPUSH(FOLLOW_identifier_in_functionName1822);
            identifier(ctx, name, check, SYM_VARIABLE);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulefunctionNameEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulefunctionNameEx; /* Prevent compiler warnings */
    rulefunctionNameEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end functionName */

/**
 * $ANTLR start functionSymbol
 * /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:452:1: functionSymbol[CVC4::Expr& fun] : functionName[name,CHECK_DECLARED] ;
 */
static void
functionSymbol(pSmt1Parser ctx, CVC4::Expr& fun)
{

    	std::string name;

    /* Initialize rule variables
     */

    {
        // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:456:3: ( functionName[name,CHECK_DECLARED] )
        // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:456:5: functionName[name,CHECK_DECLARED]
        {
            FOLLOWPUSH(FOLLOW_functionName_in_functionSymbol1844);
            functionName(ctx, name, CHECK_DECLARED);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulefunctionSymbolEx;
            }


            {
                 PARSER_STATE->checkFunctionLike(name);
                      fun = PARSER_STATE->getVariable(name); 
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulefunctionSymbolEx; /* Prevent compiler warnings */
    rulefunctionSymbolEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end functionSymbol */

/**
 * $ANTLR start attribute
 * /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:464:1: attribute[std::string& s] : ATTR_IDENTIFIER ;
 */
static void
attribute(pSmt1Parser ctx, std::string& s)
{
    pANTLR3_COMMON_TOKEN    ATTR_IDENTIFIER4;

    /* Initialize rule variables
     */

    ATTR_IDENTIFIER4       = NULL;

    {
        // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:465:3: ( ATTR_IDENTIFIER )
        // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:465:5: ATTR_IDENTIFIER
        {
            ATTR_IDENTIFIER4 = (pANTLR3_COMMON_TOKEN) MATCHT(ATTR_IDENTIFIER, &FOLLOW_ATTR_IDENTIFIER_in_attribute1867);
            if  (HASEXCEPTION())
            {
                goto ruleattributeEx;
            }


            {
                 s = AntlrInput::tokenText(ATTR_IDENTIFIER4); 
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleattributeEx; /* Prevent compiler warnings */
    ruleattributeEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end attribute */

/**
 * $ANTLR start functionDeclaration
 * /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:469:1: functionDeclaration[CVC4::Command*& smt_command] : LPAREN_TOK functionName[name,CHECK_UNDECLARED] t= sortSymbol sortList[sorts] RPAREN_TOK ;
 */
static void
functionDeclaration(pSmt1Parser ctx, CVC4::Command*& smt_command)
{

      std::string name;
      std::vector<Type> sorts;

    CVC4::parser::smt1::myType t;
    #undef	RETURN_TYPE_t
    #define	RETURN_TYPE_t CVC4::parser::smt1::myType

    /* Initialize rule variables
     */

    {
        // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:474:3: ( LPAREN_TOK functionName[name,CHECK_UNDECLARED] t= sortSymbol sortList[sorts] RPAREN_TOK )
        // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:474:5: LPAREN_TOK functionName[name,CHECK_UNDECLARED] t= sortSymbol sortList[sorts] RPAREN_TOK
        {
             MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_functionDeclaration1892);
            if  (HASEXCEPTION())
            {
                goto rulefunctionDeclarationEx;
            }


            FOLLOWPUSH(FOLLOW_functionName_in_functionDeclaration1894);
            functionName(ctx, name, CHECK_UNDECLARED);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulefunctionDeclarationEx;
            }


            FOLLOWPUSH(FOLLOW_sortSymbol_in_functionDeclaration1907);
            t=sortSymbol(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulefunctionDeclarationEx;
            }


            {
                 sorts.push_back(t); 
            }


            FOLLOWPUSH(FOLLOW_sortList_in_functionDeclaration1922);
            sortList(ctx, sorts);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulefunctionDeclarationEx;
            }


             MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_functionDeclaration1925);
            if  (HASEXCEPTION())
            {
                goto rulefunctionDeclarationEx;
            }


            {
                 if( sorts.size() == 1 ) {
                        assert( t == sorts[0] );
                      } else {
                        t = EXPR_MANAGER->mkFunctionType(sorts);
                      }
                      Expr func = PARSER_STATE->mkVar(name, t);
                      smt_command = new DeclareFunctionCommand(name, func, t);
                    
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulefunctionDeclarationEx; /* Prevent compiler warnings */
    rulefunctionDeclarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end functionDeclaration */

/**
 * $ANTLR start predicateDeclaration
 * /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:491:1: predicateDeclaration[CVC4::Command*& smt_command] : LPAREN_TOK predicateName[name,CHECK_UNDECLARED] sortList[p_sorts] RPAREN_TOK ;
 */
static void
predicateDeclaration(pSmt1Parser ctx, CVC4::Command*& smt_command)
{

      std::string name;
      std::vector<Type> p_sorts;

    /* Initialize rule variables
     */

    {
        // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:496:3: ( LPAREN_TOK predicateName[name,CHECK_UNDECLARED] sortList[p_sorts] RPAREN_TOK )
        // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:496:5: LPAREN_TOK predicateName[name,CHECK_UNDECLARED] sortList[p_sorts] RPAREN_TOK
        {
             MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_predicateDeclaration1952);
            if  (HASEXCEPTION())
            {
                goto rulepredicateDeclarationEx;
            }


            FOLLOWPUSH(FOLLOW_predicateName_in_predicateDeclaration1954);
            predicateName(ctx, name, CHECK_UNDECLARED);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulepredicateDeclarationEx;
            }


            FOLLOWPUSH(FOLLOW_sortList_in_predicateDeclaration1957);
            sortList(ctx, p_sorts);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulepredicateDeclarationEx;
            }


             MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_predicateDeclaration1960);
            if  (HASEXCEPTION())
            {
                goto rulepredicateDeclarationEx;
            }


            {
                 Type t;
                      if( p_sorts.empty() ) {
                        t = EXPR_MANAGER->booleanType();
                      } else {
                        t = EXPR_MANAGER->mkPredicateType(p_sorts);
                      }
                      Expr func = PARSER_STATE->mkVar(name, t);
                      smt_command = new DeclareFunctionCommand(name, func, t);
                    
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulepredicateDeclarationEx; /* Prevent compiler warnings */
    rulepredicateDeclarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end predicateDeclaration */

/**
 * $ANTLR start sortDeclaration
 * /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:508:1: sortDeclaration[CVC4::Command*& smt_command] : sortName[name,CHECK_UNDECLARED] ;
 */
static void
sortDeclaration(pSmt1Parser ctx, CVC4::Command*& smt_command)
{

      std::string name;

    /* Initialize rule variables
     */

    {
        // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:512:3: ( sortName[name,CHECK_UNDECLARED] )
        // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:512:5: sortName[name,CHECK_UNDECLARED]
        {
            FOLLOWPUSH(FOLLOW_sortName_in_sortDeclaration1985);
            sortName(ctx, name, CHECK_UNDECLARED);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesortDeclarationEx;
            }


            {
                 Debug("parser") << "sort decl: '" << name << "'" << std::endl;
                      Type type = PARSER_STATE->mkSort(name);
                      smt_command = new DeclareTypeCommand(name, 0, type);
                    
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesortDeclarationEx; /* Prevent compiler warnings */
    rulesortDeclarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end sortDeclaration */

/**
 * $ANTLR start sortList
 * /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:522:1: sortList[std::vector<CVC4::Type>& sorts] : (t= sortSymbol )* ;
 */
static void
sortList(pSmt1Parser ctx, std::vector<CVC4::Type>& sorts)
{
    CVC4::parser::smt1::myType t;
    #undef	RETURN_TYPE_t
    #define	RETURN_TYPE_t CVC4::parser::smt1::myType

    /* Initialize rule variables
     */

    {
        // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:523:3: ( (t= sortSymbol )* )
        // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:523:5: (t= sortSymbol )*
        {
            // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:523:5: (t= sortSymbol )*

            for (;;)
            {
                int alt23=2;
                switch ( LA(1) )
                {
                case BITVECTOR_TOK:
                case IDENTIFIER:
                case 102:
                	{
                		alt23=1;
                	}
                    break;

                }

                switch (alt23)
                {
            	case 1:
            	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:523:7: t= sortSymbol
            	    {
            	        FOLLOWPUSH(FOLLOW_sortSymbol_in_sortList2014);
            	        t=sortSymbol(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesortListEx;
            	        }


            	        {
            	             sorts.push_back(t); 
            	        }


            	    }
            	    break;

            	default:
            	    goto loop23;	/* break out of the loop */
            	    break;
                }
            }
            loop23: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesortListEx; /* Prevent compiler warnings */
    rulesortListEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end sortList */

/**
 * $ANTLR start sortName
 * /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:530:1: sortName[std::string& name, CVC4::parser::DeclarationCheck check] : identifier[name,check,SYM_SORT] ;
 */
static void
sortName(pSmt1Parser ctx, std::string& name, CVC4::parser::DeclarationCheck check)
{
    /* Initialize rule variables
     */

    {
        // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:531:3: ( identifier[name,check,SYM_SORT] )
        // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:531:5: identifier[name,check,SYM_SORT]
        {
            FOLLOWPUSH(FOLLOW_identifier_in_sortName2034);
            identifier(ctx, name, check, SYM_SORT);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesortNameEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesortNameEx; /* Prevent compiler warnings */
    rulesortNameEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end sortName */

/**
 * $ANTLR start sortSymbol
 * /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:534:1: sortSymbol returns [CVC4::parser::smt1::myType t] : ( sortName[name,CHECK_NONE] | BITVECTOR_TOK '[' NUMERAL_TOK ']' | 'Array[' n1= NUMERAL_TOK ':' n2= NUMERAL_TOK ']' );
 */
static CVC4::parser::smt1::myType
sortSymbol(pSmt1Parser ctx)
{
    CVC4::parser::smt1::myType t;



      std::string name;

    pANTLR3_COMMON_TOKEN    n1;
    pANTLR3_COMMON_TOKEN    n2;
    pANTLR3_COMMON_TOKEN    NUMERAL_TOK5;

    /* Initialize rule variables
     */

    n1       = NULL;
    n2       = NULL;
    NUMERAL_TOK5       = NULL;

    {
        {
            //  /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:538:3: ( sortName[name,CHECK_NONE] | BITVECTOR_TOK '[' NUMERAL_TOK ']' | 'Array[' n1= NUMERAL_TOK ':' n2= NUMERAL_TOK ']' )

            ANTLR3_UINT32 alt24;

            alt24=3;

            switch ( LA(1) )
            {
            case IDENTIFIER:
            	{
            		alt24=1;
            	}
                break;
            case BITVECTOR_TOK:
            	{
            		alt24=2;
            	}
                break;
            case 102:
            	{
            		alt24=3;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 24;
                EXCEPTION->state        = 0;


                goto rulesortSymbolEx;

            }

            switch (alt24)
            {
        	case 1:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:538:5: sortName[name,CHECK_NONE]
        	    {
        	        FOLLOWPUSH(FOLLOW_sortName_in_sortSymbol2057);
        	        sortName(ctx, name, CHECK_NONE);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesortSymbolEx;
        	        }


        	        {
        	             t= PARSER_STATE->getSort(name);
        	             
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:540:5: BITVECTOR_TOK '[' NUMERAL_TOK ']'
        	    {
        	         MATCHT(BITVECTOR_TOK, &FOLLOW_BITVECTOR_TOK_in_sortSymbol2069);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesortSymbolEx;
        	        }


        	         MATCHT(103, &FOLLOW_103_in_sortSymbol2071);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesortSymbolEx;
        	        }


        	        NUMERAL_TOK5 = (pANTLR3_COMMON_TOKEN) MATCHT(NUMERAL_TOK, &FOLLOW_NUMERAL_TOK_in_sortSymbol2073);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesortSymbolEx;
        	        }


        	         MATCHT(104, &FOLLOW_104_in_sortSymbol2075);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesortSymbolEx;
        	        }


        	        {

        	              	t= EXPR_MANAGER->mkBitVectorType(AntlrInput::tokenToUnsigned(NUMERAL_TOK5));

        	                
        	        }


        	    }
        	    break;
        	case 3:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:545:5: 'Array[' n1= NUMERAL_TOK ':' n2= NUMERAL_TOK ']'
        	    {
        	         MATCHT(102, &FOLLOW_102_in_sortSymbol2087);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesortSymbolEx;
        	        }


        	        n1 = (pANTLR3_COMMON_TOKEN) MATCHT(NUMERAL_TOK, &FOLLOW_NUMERAL_TOK_in_sortSymbol2091);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesortSymbolEx;
        	        }


        	         MATCHT(100, &FOLLOW_100_in_sortSymbol2093);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesortSymbolEx;
        	        }


        	        n2 = (pANTLR3_COMMON_TOKEN) MATCHT(NUMERAL_TOK, &FOLLOW_NUMERAL_TOK_in_sortSymbol2097);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesortSymbolEx;
        	        }


        	         MATCHT(104, &FOLLOW_104_in_sortSymbol2099);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesortSymbolEx;
        	        }


        	        {

        	                    t= EXPR_MANAGER->mkArrayType(EXPR_MANAGER->mkBitVectorType(AntlrInput::tokenToUnsigned(n1)),
        	                                                   EXPR_MANAGER->mkBitVectorType(AntlrInput::tokenToUnsigned(n2)));

        	                
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulesortSymbolEx; /* Prevent compiler warnings */
    rulesortSymbolEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return t;
}
/* $ANTLR end sortSymbol */

/**
 * $ANTLR start status
 * /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:554:1: status[ CVC4::BenchmarkStatus& status ] : ( SAT_TOK | UNSAT_TOK | UNKNOWN_TOK );
 */
static void
status(pSmt1Parser ctx, CVC4::BenchmarkStatus& status)
{
    /* Initialize rule variables
     */

    {
        {
            //  /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:555:3: ( SAT_TOK | UNSAT_TOK | UNKNOWN_TOK )

            ANTLR3_UINT32 alt25;

            alt25=3;

            switch ( LA(1) )
            {
            case SAT_TOK:
            	{
            		alt25=1;
            	}
                break;
            case UNSAT_TOK:
            	{
            		alt25=2;
            	}
                break;
            case UNKNOWN_TOK:
            	{
            		alt25=3;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 25;
                EXCEPTION->state        = 0;


                goto rulestatusEx;

            }

            switch (alt25)
            {
        	case 1:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:555:5: SAT_TOK
        	    {
        	         MATCHT(SAT_TOK, &FOLLOW_SAT_TOK_in_status2117);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatusEx;
        	        }


        	        {
        	             status= SMT_SATISFIABLE;    
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:556:5: UNSAT_TOK
        	    {
        	         MATCHT(UNSAT_TOK, &FOLLOW_UNSAT_TOK_in_status2131);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatusEx;
        	        }


        	        {
        	             status= SMT_UNSATISFIABLE;  
        	        }


        	    }
        	    break;
        	case 3:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:557:5: UNKNOWN_TOK
        	    {
        	         MATCHT(UNKNOWN_TOK, &FOLLOW_UNKNOWN_TOK_in_status2143);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatusEx;
        	        }


        	        {
        	             status= SMT_UNKNOWN;        
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulestatusEx; /* Prevent compiler warnings */
    rulestatusEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end status */

/**
 * $ANTLR start annotation
 * /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:564:1: annotation[CVC4::Command*& smt_command] : ( PATTERN_ANNOTATION_BEGIN annotatedFormulas[pats,pat] '}' | attribute[key] ( userValue[value] |) );
 */
static void
annotation(pSmt1Parser ctx, CVC4::Command*& smt_command)
{
    /* Initialize rule variables
     */


      std::string key, value;
      smt_command = NULL;
      std::vector<Expr> pats;
      Expr pat;

    {
        {
            //  /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:571:3: ( PATTERN_ANNOTATION_BEGIN annotatedFormulas[pats,pat] '}' | attribute[key] ( userValue[value] |) )

            ANTLR3_UINT32 alt27;

            alt27=2;

            switch ( LA(1) )
            {
            case PATTERN_ANNOTATION_BEGIN:
            	{
            		alt27=1;
            	}
                break;
            case ATTR_IDENTIFIER:
            	{
            		alt27=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 27;
                EXCEPTION->state        = 0;


                goto ruleannotationEx;

            }

            switch (alt27)
            {
        	case 1:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:571:5: PATTERN_ANNOTATION_BEGIN annotatedFormulas[pats,pat] '}'
        	    {
        	         MATCHT(PATTERN_ANNOTATION_BEGIN, &FOLLOW_PATTERN_ANNOTATION_BEGIN_in_annotation2168);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotationEx;
        	        }


        	        {
        	             PARSER_STATE->warning(":pat not supported here; ignored"); 
        	        }


        	        FOLLOWPUSH(FOLLOW_annotatedFormulas_in_annotation2180);
        	        annotatedFormulas(ctx, pats, pat);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotationEx;
        	        }


        	         MATCHT(105, &FOLLOW_105_in_annotation2183);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotationEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:574:5: attribute[key] ( userValue[value] |)
        	    {
        	        FOLLOWPUSH(FOLLOW_attribute_in_annotation2189);
        	        attribute(ctx, key);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotationEx;
        	        }


        	        // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:575:5: ( userValue[value] |)
        	        {
        	            int alt26=2;
        	            switch ( LA(1) )
        	            {
        	            case USER_VALUE:
        	            	{
        	            		alt26=1;
        	            	}
        	                break;
        	            case ASSUMPTION_TOK:
        	            case ATTR_IDENTIFIER:
        	            case EXTRAFUNS_TOK:
        	            case EXTRAPREDS_TOK:
        	            case EXTRASORTS_TOK:
        	            case FORMULA_TOK:
        	            case LOGIC_TOK:
        	            case NOTES_TOK:
        	            case PATTERN_ANNOTATION_BEGIN:
        	            case RPAREN_TOK:
        	            case STATUS_TOK:
        	            	{
        	            		alt26=2;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 26;
        	                EXCEPTION->state        = 0;


        	                goto ruleannotationEx;

        	            }

        	            switch (alt26)
        	            {
        	        	case 1:
        	        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:575:7: userValue[value]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_userValue_in_annotation2198);
        	        	        userValue(ctx, value);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleannotationEx;
        	        	        }


        	        	        {
        	        	             smt_command = new SetInfoCommand(key.c_str() + 1, value); 
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:577:7: 
        	        	    {
        	        	        {
        	        	             smt_command = new EmptyCommand(std::string("annotation: ") + key); 
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleannotationEx; /* Prevent compiler warnings */
    ruleannotationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end annotation */

/**
 * $ANTLR start termAnnotation
 * /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:585:1: termAnnotation[CVC4::Expr& expr] : ( PATTERN_ANNOTATION_BEGIN annotatedFormulas[pats,pat] '}' | ':pat' | attribute[key] ( userValue[value] )? );
 */
static void
termAnnotation(pSmt1Parser ctx, CVC4::Expr& expr)
{
    /* Initialize rule variables
     */


      std::string key, value;
      std::vector<Expr> pats;
      Expr pat;

    {
        {
            //  /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:591:3: ( PATTERN_ANNOTATION_BEGIN annotatedFormulas[pats,pat] '}' | ':pat' | attribute[key] ( userValue[value] )? )

            ANTLR3_UINT32 alt29;

            alt29=3;

            switch ( LA(1) )
            {
            case PATTERN_ANNOTATION_BEGIN:
            	{
            		alt29=1;
            	}
                break;
            case 101:
            	{
            		alt29=2;
            	}
                break;
            case ATTR_IDENTIFIER:
            	{
            		alt29=3;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 29;
                EXCEPTION->state        = 0;


                goto ruletermAnnotationEx;

            }

            switch (alt29)
            {
        	case 1:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:591:5: PATTERN_ANNOTATION_BEGIN annotatedFormulas[pats,pat] '}'
        	    {
        	         MATCHT(PATTERN_ANNOTATION_BEGIN, &FOLLOW_PATTERN_ANNOTATION_BEGIN_in_termAnnotation2242);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermAnnotationEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_annotatedFormulas_in_termAnnotation2244);
        	        annotatedFormulas(ctx, pats, pat);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermAnnotationEx;
        	        }


        	         MATCHT(105, &FOLLOW_105_in_termAnnotation2247);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermAnnotationEx;
        	        }


        	        {
        	             if(expr.getKind() == kind::FORALL || expr.getKind() == kind::EXISTS) {
        	                    pat = MK_EXPR(kind::INST_PATTERN, pats);
        	                    if(expr.getNumChildren() == 3) {
        	                      // we have other user patterns attached to the quantifier
        	                      // already; add this one to the existing list
        	                      pats = expr[2].getChildren();
        	                      pats.push_back(pat);
        	                      expr = MK_EXPR(expr.getKind(), expr[0], expr[1], MK_EXPR(kind::INST_PATTERN_LIST, pats));
        	                    } else {
        	                      // this is the only user pattern for the quantifier
        	                      expr = MK_EXPR(expr.getKind(), expr[0], expr[1], MK_EXPR(kind::INST_PATTERN_LIST, pat));
        	                    }
        	                  } else {
        	                    PARSER_STATE->warning(":pat only supported on quantifiers");
        	                  }
        	                
        	        }


        	    }
        	    break;
        	case 2:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:608:5: ':pat'
        	    {
        	         MATCHT(101, &FOLLOW_101_in_termAnnotation2259);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermAnnotationEx;
        	        }


        	        {
        	             PARSER_STATE->warning("expected an instantiation pattern after :pat"); 
        	        }


        	    }
        	    break;
        	case 3:
        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:610:5: attribute[key] ( userValue[value] )?
        	    {
        	        FOLLOWPUSH(FOLLOW_attribute_in_termAnnotation2271);
        	        attribute(ctx, key);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermAnnotationEx;
        	        }


        	        // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:610:20: ( userValue[value] )?
        	        {
        	            int alt28=2;
        	            switch ( LA(1) )
        	            {
        	                case USER_VALUE:
        	                	{
        	                		alt28=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt28)
        	            {
        	        	case 1:
        	        	    // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:610:20: userValue[value]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_userValue_in_termAnnotation2274);
        	        	        userValue(ctx, value);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletermAnnotationEx;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        {
        	             PARSER_STATE->attributeNotSupported(key); 
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruletermAnnotationEx; /* Prevent compiler warnings */
    ruletermAnnotationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end termAnnotation */

/**
 * $ANTLR start identifier
 * /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:620:1: identifier[std::string& id,\n\t\t CVC4::parser::DeclarationCheck check,\n CVC4::parser::SymbolType type] : IDENTIFIER ;
 */
static void
identifier(pSmt1Parser ctx, std::string& id, CVC4::parser::DeclarationCheck check, CVC4::parser::SymbolType type)
{
    pANTLR3_COMMON_TOKEN    IDENTIFIER6;

    /* Initialize rule variables
     */

    IDENTIFIER6       = NULL;

    {
        // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:623:3: ( IDENTIFIER )
        // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:623:5: IDENTIFIER
        {
            IDENTIFIER6 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_identifier2298);
            if  (HASEXCEPTION())
            {
                goto ruleidentifierEx;
            }


            {
                 id = AntlrInput::tokenText(IDENTIFIER6);
                      Debug("parser") << "identifier: " << id
                                      << " check? " << check
                                      << " type? " << type << std::endl;
                      PARSER_STATE->checkDeclaration(id, check, type); 
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleidentifierEx; /* Prevent compiler warnings */
    ruleidentifierEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end identifier */

/**
 * $ANTLR start let_identifier
 * /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:636:1: let_identifier[std::string& id,\n \t\t CVC4::parser::DeclarationCheck check] : LET_IDENTIFIER ;
 */
static void
let_identifier(pSmt1Parser ctx, std::string& id, CVC4::parser::DeclarationCheck check)
{
    pANTLR3_COMMON_TOKEN    LET_IDENTIFIER7;

    /* Initialize rule variables
     */

    LET_IDENTIFIER7       = NULL;

    {
        // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:638:3: ( LET_IDENTIFIER )
        // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:638:5: LET_IDENTIFIER
        {
            LET_IDENTIFIER7 = (pANTLR3_COMMON_TOKEN) MATCHT(LET_IDENTIFIER, &FOLLOW_LET_IDENTIFIER_in_let_identifier2320);
            if  (HASEXCEPTION())
            {
                goto rulelet_identifierEx;
            }


            {
                 id = AntlrInput::tokenText(LET_IDENTIFIER7);
                      Debug("parser") << "let_identifier: " << id
                                      << " check? " << check << std::endl;
                      PARSER_STATE->checkDeclaration(id, check, SYM_VARIABLE); 
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulelet_identifierEx; /* Prevent compiler warnings */
    rulelet_identifierEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end let_identifier */

/**
 * $ANTLR start flet_identifier
 * /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:650:1: flet_identifier[std::string& id,\n \t\t CVC4::parser::DeclarationCheck check] : FLET_IDENTIFIER ;
 */
static void
flet_identifier(pSmt1Parser ctx, std::string& id, CVC4::parser::DeclarationCheck check)
{
    pANTLR3_COMMON_TOKEN    FLET_IDENTIFIER8;

    /* Initialize rule variables
     */

    FLET_IDENTIFIER8       = NULL;

    {
        // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:652:3: ( FLET_IDENTIFIER )
        // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:652:5: FLET_IDENTIFIER
        {
            FLET_IDENTIFIER8 = (pANTLR3_COMMON_TOKEN) MATCHT(FLET_IDENTIFIER, &FOLLOW_FLET_IDENTIFIER_in_flet_identifier2342);
            if  (HASEXCEPTION())
            {
                goto ruleflet_identifierEx;
            }


            {
                 id = AntlrInput::tokenText(FLET_IDENTIFIER8);
                      Debug("parser") << "flet_identifier: " << id
                                      << " check? " << check << std::endl;
                      PARSER_STATE->checkDeclaration(id, check); 
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleflet_identifierEx; /* Prevent compiler warnings */
    ruleflet_identifierEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end flet_identifier */

/**
 * $ANTLR start userValue
 * /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:794:1: userValue[std::string& s] : USER_VALUE ;
 */
static void
userValue(pSmt1Parser ctx, std::string& s)
{
    pANTLR3_COMMON_TOKEN    USER_VALUE9;

    /* Initialize rule variables
     */

    USER_VALUE9       = NULL;

    {
        // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:795:3: ( USER_VALUE )
        // /home/mdeters/cvc4/builds/x86_64-unknown-linux-gnu/production/../../../src/parser/smt1/Smt1.g:795:5: USER_VALUE
        {
            USER_VALUE9 = (pANTLR3_COMMON_TOKEN) MATCHT(USER_VALUE, &FOLLOW_USER_VALUE_in_userValue3590);
            if  (HASEXCEPTION())
            {
                goto ruleuserValueEx;
            }


            {
                 s = AntlrInput::tokenText(USER_VALUE9);
                      assert(*s.begin() == '{');
                      assert(*s.rbegin() == '}');
                      // trim whitespace
                      s.erase(s.begin(), s.begin() + 1);
                      s.erase(s.begin(), std::find_if(s.begin(), s.end(), std::not1(std::ptr_fun<int, int>(std::isspace))));
                      s.erase(s.end() - 1);
                      s.erase(std::find_if(s.rbegin(), s.rend(), std::not1(std::ptr_fun<int, int>(std::isspace))).base(), s.end());
                    
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleuserValueEx; /* Prevent compiler warnings */
    ruleuserValueEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end userValue */
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
/* End of syntactic predicates
 * ==============================================
 */






/* End of code
 * =============================================================================
 */
