#!/usr/bin/python

# @author: rakesh mistry - 'inspire'
# @date: 2015-06-14

import sys
import re
import os
import math
import random

################################################################################
# Functions to generate SMT2 expressions
def extractExpr(m, n, var):
    return "((_ extract " + str(m) + " " + str(n) + ") " + str(var) + ")"

def xorExpr(var1, var2):
    return "(xor " + str(var1) + " " + str(var2) + ")"

def zeroExtendExpr(bitWidth, varName):
    return "((_ zero_extend " + str(bitWidth) + ") " + varName + ")"

def bvmulExpr(var1, var2):
    return "(bvmul " + str(var1) + " " + str(var2) + ")"

def bvaddExpr(var1, var2):
    return "(bvadd " + str(var1) + " " + str(var2) + ")"

def eqExpr(var1, var2):
    return "(= " + str(var1) + " " + str(var2) + ")"

def constExpr(num, bitWidth):
    return "(_ bv" + str(num) + " " + str(bitWidth) + ")"

def andExpr(var1, var2):
    return "(and " + str(var1) + " " + str(var2) + ")"

################################################################################


# Function: populatePrimesMap
# @param: primesMap - file containing primes.
#         Each line is of the form -- k prime
#         where for every number 'k' the value of 'prime' is smallest prime > 2^k
#
# updates global map 'primesMap' of prime numbers for 2^k (1 <= k <= 100)
def populatePrimesMap(primesFile):
    primesMap = {}
    for line in primesFile:
        strList = line.split()
        k = int(strList[0])
        primesMap[k] = int(strList[1])

    return primesMap


# Function: generateEquationConstraint
# @param: varmap - a map of variables with key as variable name and value being
#         its width
# @param: maxBitwidth - maximum bitwidth
# @param: slices - number of slices for each variable to create
#
# Generates an equation of the form:
#     a1x1 + a2x2 + ... = s*prime + r
def generateEquationConstraint(varMap, primesMap, maxBitwidth, slices):
    generateEquationConstraint.counter += 1
    k = maxBitwidth
    twoPowerK = 2 ** k
    prime = primesMap[maxBitwidth]

    newBitwidth = maxBitwidth + int(math.ceil(math.log(slices * len(varMap), 2))) + 1

    primeCoeff = "temp_prime_coeff_" + str(generateEquationConstraint.counter)
    primeCoeffDecl = "(declare-fun " + primeCoeff + " () (_ BitVec " + str(newBitwidth - (maxBitwidth + 1)) + "))\n"

    bvmulList = []
    for key in varMap.keys():
        if varMap[key] > 1: # subdivide if width > 1
            keyDivWidth = varMap[key] / slices
            bitRemaining = varMap[key] % slices

            if keyDivWidth == 0:
                slices = bitRemaining

            keyDivWidthList = [keyDivWidth] * slices

            for i in range(bitRemaining):
                keyDivWidthList[i] += 1

            coeff = []
            for i in range(slices):
                coeff.append(random.randint(0, twoPowerK - 1))

            keyDivs = []
            msbPos = varMap[key] - 1
            for i in range(slices):
                keyDivs.append(extractExpr(msbPos, msbPos - keyDivWidthList[i] + 1, key))
                msbPos = msbPos - keyDivWidthList[i]

            zxtndKeyDivs = []
            for i in range(slices):
                zxtndKeyDivs.append(zeroExtendExpr(newBitwidth - keyDivWidthList[i], keyDivs[i]))

            bvmulStrs = []
            for i in range(slices):
                bvmulList.append(bvmulExpr(constExpr(coeff[i], newBitwidth), zxtndKeyDivs[i]))

        else:
            coeff = random.randint(0, twoPowerK - 1)
            zxtndKey = zeroExtendExpr(newBitwidth - varMap[key], key)
            bvmulStr = bvmulExpr(constExpr(coeff, newBitwidth), zxtndKey)
            bvmulList.append(bvmulStr)

    lhsStr = reduce(lambda x, y: bvaddExpr(x, y), bvmulList)

    s = zeroExtendExpr(k + 1, primeCoeff)
    r = random.randint(0, prime - 1)

    rhsStr = bvaddExpr(bvmulExpr(constExpr(prime, newBitwidth), s), constExpr(r, newBitwidth))
    constraint = eqExpr(lhsStr, rhsStr)
    return constraint, primeCoeffDecl


# Function: parseSmt2File
# @param: smt2File - input SMT2 file
# @return: varmap - a map containing as key the names of the variables and value as their bitwidth
# @return: smtFilePrefix - string containing the initial part of smt2File (until start of 'assert' in 'smt2File')
#
# Creates variable map and also copies the initial part of SMT2 file (until start of 'assert' in 'smt2File')
# This would later be appended with our constraints to create the new SMT2 file
def parseSmt2FileVariables(smt2File):
    # create regex to specific lines
    compiledVarPattern = re.compile("[ \t]*\(declare-fun")
    compiledAssertPattern = re.compile("assert")

    # read variable info in map
    varMap = {}

    scriptName = os.path.basename(__file__)    
    smtFilePrefix = "; [" + scriptName + "] Autogenerated from source file: " + smt2File.name + "\n"
    for line in smt2File:
        smtFilePrefix += line
        if compiledVarPattern.search(line):
            wordList = line.split()
            varName = wordList[1]

            varWidthStr = wordList[-1].rstrip(")")
            if varWidthStr.isdigit():
                varWidth = int(varWidthStr)
                varMap[varName] = varWidth
        elif compiledAssertPattern.search(line):
            break

    return varMap, smtFilePrefix


# Function: parseSmt2File
# @param: smt2File - input SMT2 file
# @param: newConstraints - string which is a SMT2 constraint
# @return: smtFileSuffix - string containing our constraints followed by rest of input file
#
# returns a string after our adding our constraints to the rest of the input file
def parseSmt2FileSuffix(smt2File, newConstraints):
    compiledCheckSatPattern = re.compile("check-sat")

    smtFileSuffix = ""
    for line in smt2File:
        if compiledCheckSatPattern.search(line):
            smtFileSuffix += "(assert"
            smtFileSuffix += " " + newConstraints + ")\n"
            smtFileSuffix += line
            break
        smtFileSuffix += line

    # write everything after '(check-sat)'
    for line in smt2File:
        smtFileSuffix += line

    return smtFileSuffix

# Function: generateSMT2FileFromConstraints
def generateSMT2FileFromConstraints(smt2prefix, coeffDeclList, constraintList, smt2suffix, tempFileName):
    outputSMT2File = open(tempFileName, "w")
    outputSMT2File.write(smt2prefix)

    for decl in coeffDeclList:
        outputSMT2File.write(decl)

    outputSMT2File.write("(assert")

    strConstraints = reduce(lambda x, y: andExpr(x, y), constraintList)
    outputSMT2File.write(strConstraints)

    outputSMT2File.write(")\n")
    outputSMT2File.write(smt2suffix)

    outputSMT2File.close()


# Function: generateSMT1FromSMT2File
def generateSMT1FromSMT2File(smt2FileName, smt1FileName):
    cmd = "boolector -ds1 -o " + smt1FileName + " " + smt2FileName
    return os.system(cmd)


# Funtion: countSolutions
def countSolutions(smtResultsFileName):
    smtResultsFile = open(smtResultsFileName, "r")

    for line in smtResultsFile:
        strList = line.split();
        if strList[0] == "numSolutions":
            return int(strList[1])

    return 0


# Function: main
def main(argv):
    global numVars
    global tempPrimeCoeffList
    generateEquationConstraint.counter = 0;

    # check for correct number of arguments
    scriptName = os.path.basename(__file__)
    if len(argv) < 2:
        sys.stderr.write("Error: Invalid arguments.\n")
        sys.stderr.write("    [Usage]: " + scriptName + " <input_SMT2_file> <primes_file>\n")
        sys.exit(1)

    # open files
    inputSMTFile = open(argv[1], "r")
    primesFile = open(argv[2], "r")

    primesMap = populatePrimesMap(primesFile)

    (varMap, smt2prefix) = parseSmt2FileVariables(inputSMTFile)
    smt2suffix = parseSmt2FileSuffix(inputSMTFile, "true")

    maxBitwidth = max(varMap.values())
    print "maxBitwidth: " + str(maxBitwidth)

    # find pivot solutions
    tempDir = os.getcwd() + "/temp_amc"
    smtSolver = "/home/intelproject/Desktop/boolector/boolector-mc/boolector/boolector"

    tempSMT2FileName = tempDir + "/temp.smt2"
    tempOutputFile = tempDir + "/solverResults.txt"
    tempSMT1FileName = tempDir + "/temp.smt1"

    constraintList = []
    coeffDeclList = []

    if not os.path.exists(tempDir):
        os.makedirs(tempDir)

    slices = 2
    timeout = 30
    minPivot = 5
    maxPivot = 10

    (constraint, coeffDecl) = generateEquationConstraint(varMap, primesMap, maxBitwidth, slices)
    constraintList.append(constraint)
    coeffDeclList.append(coeffDecl)

    while True:
        generateSMT2FileFromConstraints(smt2prefix, coeffDeclList, constraintList, smt2suffix, tempSMT2FileName)
        conversionResult = generateSMT1FromSMT2File(tempSMT2FileName, tempSMT1FileName)
        if conversionResult != 0:
            sys.stderr.write("Error while converting from SMT2 File to SMT1 file. Aborting ...\n")
            exit(1)

        cmd = smtSolver + " -i -m -t " + str(timeout) + " --maxsolutions=" + str(maxPivot) + " " + tempSMT1FileName + " >" + tempOutputFile;
        os.system(cmd)
        numSolutions = countSolutions(tempOutputFile)

        print "slices: " + str(slices) + ", numSolutions: " + str(numSolutions)
        
        if numSolutions >= minPivot:
            (constraint, coeffDecl) = generateEquationConstraint(varMap, primesMap, maxBitwidth, slices)
            constraintList.append(constraint)
            coeffDeclList.append(coeffDecl)

        elif numSolutions >= 0:
            constraintList.pop()
            coeffDeclList.pop()
            if (slices >= maxBitwidth):
                break
            slices = slices * 2;

            (constraint, coeffDecl) = generateEquationConstraint(varMap, primesMap, maxBitwidth, slices)
            constraintList.append(constraint)
            coeffDeclList.append(coeffDecl)

    print "slices: " + str(slices)

if __name__ == "__main__":
    main(sys.argv)
